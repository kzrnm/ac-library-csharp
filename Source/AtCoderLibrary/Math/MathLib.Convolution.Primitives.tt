<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    Type[] types = new[]
    {
        typeof(int),
        typeof(uint),
        typeof(long),
        typeof(ulong),
    };
#>
// <auto-generated>
// DO NOT CHANGE THIS FILE.
// </auto-generated>
using System;

namespace AtCoder
{
    public static partial class MathLib
    {
<# foreach(var t in types) { #>
        /// <summary>
        /// 畳み込みを mod <paramref name="m"/> = 998244353 で計算します。
        /// </summary>
        /// <remarks>
        /// <para><paramref name="a"/>, <paramref name="b"/> の少なくとも一方が空の場合は空配列を返します。</para>
        /// <para>制約:</para>
        /// <para>- 2≤<paramref name="m"/>≤2×10^9</para>
        /// <para>- <paramref name="m"/> は素数</para>
        /// <para>- 2^c | (<paramref name="m"/> - 1) かつ |<paramref name="a"/>| + |<paramref name="b"/>| - 1 ≤ 2^c なる c が存在する</para>
        /// <para>計算量: O((|<paramref name="a"/>|+|<paramref name="b"/>|)log(|<paramref name="a"/>|+|<paramref name="b"/>|) + log<paramref name="m"/>)</para>
        /// </remarks>
        public static <#= t.Name #>[] Convolution(<#= t.Name #>[] a, <#= t.Name #>[] b) => Convolution<Mod998244353>(a, b);

        /// <summary>
        /// 畳み込みを mod <typeparamref name="TMod"/> で計算します。
        /// </summary>
        /// <remarks>
        /// <para><paramref name="a"/>, <paramref name="b"/> の少なくとも一方が空の場合は空配列を返します。</para>
        /// <para>制約:</para>
        /// <para>- 2≤<typeparamref name="TMod"/>≤2×10^9</para>
        /// <para>- <typeparamref name="TMod"/> は素数</para>
        /// <para>- 2^c | (<typeparamref name="TMod"/> - 1) かつ |<paramref name="a"/>| + |<paramref name="b"/>| - 1 ≤ 2^c なる c が存在する</para>
        /// <para>計算量: O((|<paramref name="a"/>|+|<paramref name="b"/>|)log(|<paramref name="a"/>|+|<paramref name="b"/>|) + log<typeparamref name="TMod"/>)</para>
        /// </remarks>
        public static <#= t.Name #>[] Convolution<TMod>(<#= t.Name #>[] a, <#= t.Name #>[] b) where TMod : struct, IStaticMod
            => Convolution<TMod>(a.AsSpan(), b.AsSpan());
        /// <summary>
        /// 畳み込みを mod <typeparamref name="TMod"/> で計算します。
        /// </summary>
        /// <remarks>
        /// <para><paramref name="a"/>, <paramref name="b"/> の少なくとも一方が空の場合は空配列を返します。</para>
        /// <para>制約:</para>
        /// <para>- 2≤<typeparamref name="TMod"/>≤2×10^9</para>
        /// <para>- <typeparamref name="TMod"/> は素数</para>
        /// <para>- 2^c | (<typeparamref name="TMod"/> - 1) かつ |<paramref name="a"/>| + |<paramref name="b"/>| - 1 ≤ 2^c なる c が存在する</para>
        /// <para>計算量: O((|<paramref name="a"/>|+|<paramref name="b"/>|)log(|<paramref name="a"/>|+|<paramref name="b"/>|) + log<typeparamref name="TMod"/>)</para>
        /// </remarks>
        public static <#= t.Name #>[] Convolution<TMod>(ReadOnlySpan<<#= t.Name #>> a, ReadOnlySpan<<#= t.Name #>> b) where TMod : struct, IStaticMod
        {
            var n = a.Length;
            var m = b.Length;
            if (n == 0 || m == 0)
            {
                return Array.Empty<<#= t.Name #>>();
            }

            var a2 = new StaticModInt<TMod>[n];
            var b2 = new StaticModInt<TMod>[m];
            for (int i = 0; i < a2.Length; i++)
            {
                a2[i] = new StaticModInt<TMod>(a[i]);
            }
            for (int i = 0; i < b2.Length; i++)
            {
                b2[i] = new StaticModInt<TMod>(b[i]);
            }

            var c2 = Convolution(a2, b2);
            var c = new <#= t.Name #>[n + m - 1];
            for (int i = 0; i < c.Length; i++)
            {
                c[i] = (<#= t.Name #>)c2[i].Value;
            }
            return c;
        }
<# } #>
    }
}