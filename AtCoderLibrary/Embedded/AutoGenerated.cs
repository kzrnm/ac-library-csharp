using System.Collections.ObjectModel;
using System.ComponentModel;
using System.CodeDom.Compiler;
namespace AtCoder.Embedded
{
    [EditorBrowsable(EditorBrowsableState.Never)]
    [GeneratedCodeAttribute("SourceCodeEmbedded", "1.0.0.0")]
    public class AclFileInfo
    {
        public string FileName { get; }
        public ReadOnlyCollection<string> TypeNames { get; }
        public ReadOnlyCollection<string> Usings { get; }
        public ReadOnlyCollection<string> Dependencies { get; }
        public string CodeBody { get; }
        public AclFileInfo(string fileName, string[] typeNames, string[] usings, string[] dependencies, string code)
        {
            FileName = fileName;
            TypeNames = new ReadOnlyCollection<string>(typeNames);
            Usings = new ReadOnlyCollection<string>(usings);
            Dependencies = new ReadOnlyCollection<string>(dependencies);
            CodeBody = code;
        }
    }
    [EditorBrowsable(EditorBrowsableState.Never)]
    [GeneratedCodeAttribute("SourceCodeEmbedded", "1.0.0.0")]
    public static class AutoGenerated__SourceInfo
    {
        public static readonly ReadOnlyCollection<AclFileInfo> FileInfo
            = new ReadOnlyCollection<AclFileInfo>(new AclFileInfo[]
            {
new AclFileInfo(@"DataStructure/LazySegtree.cs", new string[] { @"AtCoder.IMonoidFuncOperator<T, F>", @"AtCoder.LazySegtree<TValue, F, TOp>", @"AtCoder.LazySegtree<TValue, F, TOp>.DebugItem", @"AtCoder.LazySegtree<TValue, F, TOp>.DebugView" }, new string[] { @"using System;", @"using System.Collections.Generic;", @"using System.Diagnostics;", @"using System.Runtime.CompilerServices;", @"using AtCoder.Internal;" }, new string[] { @"Bit/Internal/InternalBit.cs" }, @"namespace AtCoder { public interface IMonoidFuncOperator<T, F> { T Identity { get; } F FIdentity { get; } T Operate(T x, T y); T Mapping(F f, T x); F Composition(F f, F g); } [DebuggerTypeProxy(typeof(LazySegtree<,,>.DebugView))] public class LazySegtree<TValue, F, TOp> where TOp : struct, IMonoidFuncOperator<TValue, F> { private static readonly TOp op = default; public int Length { get; } private readonly int log; private readonly int size; private readonly TValue[] d; private readonly F[] lz; public LazySegtree(int n) { Debug.Assert(0 <= n); AssertMonoid(op.Identity); AssertFIdentity(op.Identity); AssertF(op.FIdentity, op.Identity, op.Identity); Length = n; log = InternalBit.CeilPow2(n); size = 1 << log; d = new TValue[2 * size]; lz = new F[size]; Array.Fill(d, op.Identity); Array.Fill(lz, op.FIdentity); } public LazySegtree(TValue[] v) : this(v.Length) { for (int i = 0; i < v.Length; i++) d[size + i] = v[i]; for (int i = size - 1; i >= 1; i--) { Update(i); } } [MethodImpl(MethodImplOptions.AggressiveInlining)] private void Update(int k) => d[k] = op.Operate(d[2 * k], d[2 * k + 1]); [MethodImpl(MethodImplOptions.AggressiveInlining)] private void AllApply(int k, F f) { AssertF(f, op.Identity, op.Identity); AssertMonoid(d[k]); AssertFIdentity(d[k]); AssertF(f, d[k], d[k]); d[k] = op.Mapping(f, d[k]); if (k < size) lz[k] = op.Composition(f, lz[k]); } [MethodImpl(MethodImplOptions.AggressiveInlining)] private void Push(int k) { AllApply(2 * k, lz[k]); AllApply(2 * k + 1, lz[k]); lz[k] = op.FIdentity; } public TValue this[int p] { [MethodImpl(MethodImplOptions.AggressiveInlining)] set { Debug.Assert((uint)p < Length); p += size; for (int i = log; i >= 1; i--) Push(p >> i); d[p] = value; for (int i = 1; i <= log; i++) Update(p >> i); } [MethodImpl(MethodImplOptions.AggressiveInlining)] get { Debug.Assert((uint)p < Length); p += size; for (int i = log; i >= 1; i--) Push(p >> i); return d[p]; } } [MethodImpl(MethodImplOptions.AggressiveInlining)] public TValue Prod(int l, int r) { Debug.Assert(0 <= l && l <= r && r <= Length); if (l == r) return op.Identity; l += size; r += size; for (int i = log; i >= 1; i--) { if (((l >> i) << i) != l) Push(l >> i); if (((r >> i) << i) != r) Push(r >> i); } TValue sml = op.Identity, smr = op.Identity; while (l < r) { if ((l & 1) != 0) sml = op.Operate(sml, d[l++]); if ((r & 1) != 0) smr = op.Operate(d[--r], smr); l >>= 1; r >>= 1; } return op.Operate(sml, smr); } public TValue AllProd => d[1]; public void Apply(int p, F f) { Debug.Assert((uint)p < Length); p += size; for (int i = log; i >= 1; i--) Push(p >> i); d[p] = op.Mapping(f, d[p]); for (int i = 1; i <= log; i++) Update(p >> i); } public void Apply(int l, int r, F f) { Debug.Assert(0 <= l && l <= r && r <= Length); if (l == r) return; l += size; r += size; for (int i = log; i >= 1; i--) { if (((l >> i) << i) != l) Push(l >> i); if (((r >> i) << i) != r) Push((r - 1) >> i); } { int l2 = l, r2 = r; while (l < r) { if ((l & 1) != 0) AllApply(l++, f); if ((r & 1) != 0) AllApply(--r, f); l >>= 1; r >>= 1; } l = l2; r = r2; } for (int i = 1; i <= log; i++) { if (((l >> i) << i) != l) Update(l >> i); if (((r >> i) << i) != r) Update((r - 1) >> i); } } public int MaxRight(int l, Predicate<TValue> g) { Debug.Assert((uint)l <= Length); Debug.Assert(g(op.Identity)); if (l == Length) return Length; l += size; for (int i = log; i >= 1; i--) Push(l >> i); TValue sm = op.Identity; do { while (l % 2 == 0) l >>= 1; if (!g(op.Operate(sm, d[l]))) { while (l < size) { Push(l); l = (2 * l); if (g(op.Operate(sm, d[l]))) { sm = op.Operate(sm, d[l]); l++; } } return l - size; } sm = op.Operate(sm, d[l]); l++; } while ((l & -l) != l); return Length; } public int MinLeft(int r, Predicate<TValue> g) { Debug.Assert((uint)r <= Length); Debug.Assert(g(op.Identity)); if (r == 0) return 0; r += size; for (int i = log; i >= 1; i--) Push((r - 1) >> i); TValue sm = op.Identity; do { r--; while (r > 1 && (r % 2) != 0) r >>= 1; if (!g(op.Operate(d[r], sm))) { while (r < size) { Push(r); r = (2 * r + 1); if (g(op.Operate(d[r], sm))) { sm = op.Operate(d[r], sm); r--; } } return r + 1 - size; } sm = op.Operate(d[r], sm); } while ((r & -r) != r); return 0; } [DebuggerDisplay(""Value = {"" + nameof(value) + ""}, Lazy = {"" + nameof(lazy) + ""}"", Name = ""{"" + nameof(key) + "",nq}"")] private struct DebugItem { public DebugItem(int l, int r, TValue value, F lazy) { if (r - l == 1) key = $""[{l}]""; else key = $""[{l}-{r})""; this.value = value; this.lazy = lazy; } [DebuggerBrowsable(DebuggerBrowsableState.Never)] private readonly string key; [DebuggerBrowsable(DebuggerBrowsableState.Never)] private readonly TValue value; [DebuggerBrowsable(DebuggerBrowsableState.Never)] private readonly F lazy; } private class DebugView { private readonly LazySegtree<TValue, F, TOp> segtree; public DebugView(LazySegtree<TValue, F, TOp> segtree) { this.segtree = segtree; } [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)] public DebugItem[] Items { get { var items = new List<DebugItem>(segtree.Length); for (int len = segtree.size; len > 0; len >>= 1) { int unit = segtree.size / len; for (int i = 0; i < len; i++) { int l = i * unit; int r = Math.Min(l + unit, segtree.Length); if (l < segtree.Length) { int dataIndex = i + len; if ((uint)dataIndex < segtree.lz.Length) items.Add(new DebugItem(l, r, segtree.d[dataIndex], segtree.lz[dataIndex])); else items.Add(new DebugItem(l, r, segtree.d[dataIndex], op.FIdentity)); } } } return items.ToArray(); } } } [Conditional(""DEBUG"")] public static void AssertMonoid(TValue value) { Debug.Assert(op.Operate(value, op.Identity).Equals(value), $""{nameof(op.Operate)}({value}, {op.Identity}) != {value}""); Debug.Assert(op.Operate(op.Identity, value).Equals(value), $""{nameof(op.Operate)}({op.Identity}, {value}) != {value}""); } [Conditional(""DEBUG"")] public static void AssertFIdentity(TValue value) { Debug.Assert(op.Mapping(op.FIdentity, value).Equals(value), $""{nameof(op.Mapping)}({op.Identity}, {value}) != {value}""); } [Conditional(""DEBUG"")] public static void AssertF(F f, TValue v1, TValue v2) { Debug.Assert(op.Mapping(op.FIdentity, op.Operate(v1, v2)).Equals(op.Operate(op.Mapping(op.FIdentity, v1), op.Mapping(op.FIdentity, v2))), $""{nameof(op.Mapping)}({nameof(op.Operate)}({v1}, {v2})) != {nameof(op.Operate)}({nameof(op.Mapping)}({op.Identity}, {v1}), {nameof(op.Mapping)}({op.Identity}, {v2}))""); } } } "),
new AclFileInfo(@"DataStructure/Segtree.cs", new string[] { @"AtCoder.IMonoidOperator<T>", @"AtCoder.Segtree<TValue, TOp>", @"AtCoder.Segtree<TValue, TOp>.DebugItem", @"AtCoder.Segtree<TValue, TOp>.DebugView" }, new string[] { @"using System;", @"using System.Collections.Generic;", @"using System.Diagnostics;", @"using System.Runtime.CompilerServices;", @"using AtCoder.Internal;" }, new string[] { @"Bit/Internal/InternalBit.cs" }, @"namespace AtCoder { public interface IMonoidOperator<T> { T Identity { get; } T Operate(T x, T y); } [DebuggerTypeProxy(typeof(Segtree<,>.DebugView))] public class Segtree<TValue, TOp> where TOp : struct, IMonoidOperator<TValue> { private static readonly TOp op = default; public int Length { get; } private readonly int log; private readonly int size; private readonly TValue[] d; public Segtree(int n) { Debug.Assert(0 <= n); AssertMonoid(op.Identity); Length = n; log = InternalBit.CeilPow2(n); size = 1 << log; d = new TValue[2 * size]; Array.Fill(d, op.Identity); } public Segtree(TValue[] v) : this(v.Length) { for (int i = 0; i < v.Length; i++) d[size + i] = v[i]; for (int i = size - 1; i >= 1; i--) { Update(i); } } [MethodImpl(MethodImplOptions.AggressiveInlining)] private void Update(int k) => d[k] = op.Operate(d[2 * k], d[2 * k + 1]); public TValue this[int p] { [MethodImpl(MethodImplOptions.AggressiveInlining)] set { AssertMonoid(value); Debug.Assert((uint)p < Length); p += size; d[p] = value; for (int i = 1; i <= log; i++) Update(p >> i); } [MethodImpl(MethodImplOptions.AggressiveInlining)] get { Debug.Assert((uint)p < Length); AssertMonoid(d[p + size]); return d[p + size]; } } [MethodImpl(MethodImplOptions.AggressiveInlining)] public TValue Prod(int l, int r) { Debug.Assert(0 <= l && l <= r && r <= Length); TValue sml = op.Identity, smr = op.Identity; l += size; r += size; while (l < r) { if ((l & 1) != 0) sml = op.Operate(sml, d[l++]); if ((r & 1) != 0) smr = op.Operate(d[--r], smr); l >>= 1; r >>= 1; } AssertMonoid(op.Operate(sml, smr)); return op.Operate(sml, smr); } public TValue AllProd => d[1]; public int MaxRight(int l, Predicate<TValue> f) { Debug.Assert((uint)l <= Length); Debug.Assert(f(op.Identity)); if (l == Length) return Length; l += size; var sm = op.Identity; do { while (l % 2 == 0) l >>= 1; if (!f(op.Operate(sm, d[l]))) { while (l < size) { l = (2 * l); if (f(op.Operate(sm, d[l]))) { sm = op.Operate(sm, d[l]); l++; } } return l - size; } sm = op.Operate(sm, d[l]); l++; } while ((l & -l) != l); return Length; } public int MinLeft(int r, Predicate<TValue> f) { Debug.Assert((uint)r <= Length); Debug.Assert(f(op.Identity)); if (r == 0) return 0; r += size; var sm = op.Identity; do { r--; while (r > 1 && (r % 2) != 0) r >>= 1; if (!f(op.Operate(d[r], sm))) { while (r < size) { r = (2 * r + 1); if (f(op.Operate(d[r], sm))) { sm = op.Operate(d[r], sm); r--; } } return r + 1 - size; } sm = op.Operate(d[r], sm); } while ((r & -r) != r); return 0; } [DebuggerDisplay(""{"" + nameof(value) + ""}"", Name = ""{"" + nameof(key) + "",nq}"")] private struct DebugItem { public DebugItem(int l, int r, TValue value) { if (r - l == 1) key = $""[{l}]""; else key = $""[{l}-{r})""; this.value = value; } [DebuggerBrowsable(DebuggerBrowsableState.Never)] private readonly string key; [DebuggerBrowsable(DebuggerBrowsableState.Never)] private readonly TValue value; } private class DebugView { private readonly Segtree<TValue, TOp> segtree; public DebugView(Segtree<TValue, TOp> segtree) { this.segtree = segtree; } [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)] public DebugItem[] Items { get { var items = new List<DebugItem>(segtree.Length); for (int len = segtree.size; len > 0; len >>= 1) { int unit = segtree.size / len; for (int i = 0; i < len; i++) { int l = i * unit; int r = Math.Min(l + unit, segtree.Length); if (l < segtree.Length) items.Add(new DebugItem(l, r, segtree.d[i + len])); } } return items.ToArray(); } } } [Conditional(""DEBUG"")] public static void AssertMonoid(TValue value) { Debug.Assert(op.Operate(value, op.Identity).Equals(value), $""{nameof(op.Operate)}({value}, {op.Identity}) != {value}""); Debug.Assert(op.Operate(op.Identity, value).Equals(value), $""{nameof(op.Operate)}({op.Identity}, {value}) != {value}""); } } } "),
new AclFileInfo(@"DataStructure/FenwickTree.cs", new string[] { @"AtCoder.IntFenwickTree", @"AtCoder.UIntFenwickTree", @"AtCoder.LongFenwickTree", @"AtCoder.ULongFenwickTree", @"AtCoder.ModIntFenwickTree<T>", @"AtCoder.FenwickTree<TValue, TOp>", @"AtCoder.FenwickTree<TValue, TOp>.DebugItem", @"AtCoder.FenwickTree<TValue, TOp>.DebugView" }, new string[] { @"using System.Diagnostics;", @"using System.Runtime.CompilerServices;", @"using AtCoder.Internal;" }, new string[] { @"Algebra/Operators.cs", @"Math/ModInt.cs", @"Bit/Internal/InternalBit.cs" }, @"namespace AtCoder { public class IntFenwickTree : FenwickTree<int, IntOperator> { public IntFenwickTree(int n) : base(n) { } } public class UIntFenwickTree : FenwickTree<uint, UIntOperator> { public UIntFenwickTree(int n) : base(n) { } } public class LongFenwickTree : FenwickTree<long, LongOperator> { public LongFenwickTree(int n) : base(n) { } } public class ULongFenwickTree : FenwickTree<ulong, ULongOperator> { public ULongFenwickTree(int n) : base(n) { } } public class ModIntFenwickTree<T> : FenwickTree<StaticModInt<T>, StaticModIntOperator<T>> where T : struct, IStaticMod { public ModIntFenwickTree(int n) : base(n) { } } [DebuggerTypeProxy(typeof(FenwickTree<,>.DebugView))] public class FenwickTree<TValue, TOp> where TOp : IAddOperator<TValue>, ISubtractOperator<TValue> { private static readonly TOp op = default; private readonly TValue[] data; public FenwickTree(int n) { Debug.Assert(unchecked((uint)n <= 100_000_000)); data = new TValue[n + 1]; } [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Add(int p, TValue x) { Debug.Assert(unchecked((uint)p < data.Length)); for (p++; p < data.Length; p += InternalBit.ExtractLowestSetBit(p)) { data[p] = op.Add(data[p], x); } } [MethodImpl(MethodImplOptions.AggressiveInlining)] public TValue Sum(int l, int r) { Debug.Assert(0 <= l && l <= r && r < data.Length); return op.Subtract(Sum(r), Sum(l)); } [MethodImpl(MethodImplOptions.AggressiveInlining)] private TValue Sum(int r) { TValue s = default; for (; r > 0; r -= InternalBit.ExtractLowestSetBit(r)) { s = op.Add(s, data[r]); } return s; } [DebuggerDisplay(""Value = {"" + nameof(value) + ""}, Sum = {"" + nameof(sum) + ""}"")] internal struct DebugItem { public DebugItem(TValue value, TValue sum) { this.sum = sum; this.value = value; } [DebuggerBrowsable(DebuggerBrowsableState.Never)] public readonly TValue value; [DebuggerBrowsable(DebuggerBrowsableState.Never)] public readonly TValue sum; } internal class DebugView { private readonly FenwickTree<TValue, TOp> fenwickTree; public DebugView(FenwickTree<TValue, TOp> fenwickTree) { this.fenwickTree = fenwickTree; } [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)] public DebugItem[] Items { get { var data = fenwickTree.data; var items = new DebugItem[data.Length - 1]; items[0] = new DebugItem(data[1], data[1]); for (int i = 2; i < data.Length; i++) { int length = InternalBit.ExtractLowestSetBit(i); var pr = i - length - 1; var sum = op.Add(data[i], 0 <= pr ? items[pr].sum : default); var val = op.Subtract(sum, items[i - 2].sum); items[i - 1] = new DebugItem(val, sum); } return items; } } } } } "),
new AclFileInfo(@"Algebra/Operators.cs", new string[] { @"AtCoder.IAddOperator<T>", @"AtCoder.ISubtractOperator<T>", @"AtCoder.IMultiplyOperator<T>", @"AtCoder.IDivideOperator<T>", @"AtCoder.IModuloOperator<T>", @"AtCoder.INegateOperator<T>", @"AtCoder.IIncrementOperator<T>", @"AtCoder.IDecrementOperator<T>", @"AtCoder.IComparisonOperator<T>", @"AtCoder.IRangedType<T>", @"AtCoder.IUnsignedNumOperator<T>", @"AtCoder.ISignedNumOperator<T>", @"AtCoder.IntOperator", @"AtCoder.LongOperator", @"AtCoder.UIntOperator", @"AtCoder.ULongOperator", @"AtCoder.DoubleOperator" }, new string[] { @"using System.Collections.Generic;" }, new string[] {  }, @"namespace AtCoder { public interface IAddOperator<T> { T Add(T x, T y); } public interface ISubtractOperator<T> { T Subtract(T x, T y); } public interface IMultiplyOperator<T> { T Multiply(T x, T y); } public interface IDivideOperator<T> { T Divide(T x, T y); } public interface IModuloOperator<T> { T Modulo(T x, T y); } public interface INegateOperator<T> { T Negate(T x); } public interface IIncrementOperator<T> : IAddOperator<T> { T Increment(T x); } public interface IDecrementOperator<T> : ISubtractOperator<T> { T Decrement(T x); } public interface IComparisonOperator<T> : IComparer<T> { bool GreaterThan(T x, T y); bool GreaterThanOrEqual(T x, T y); bool LessThan(T x, T y); bool LessThanOrEqual(T x, T y); } public interface IRangedType<T> { public T MinValue { get; } public T MaxValue { get; } } public interface IUnsignedNumOperator<T> : IAddOperator<T>, ISubtractOperator<T>, IMultiplyOperator<T>, IDivideOperator<T>, IModuloOperator<T>, IIncrementOperator<T>, IDecrementOperator<T>, IComparisonOperator<T>, IRangedType<T>, IEqualityComparer<T> { } public interface ISignedNumOperator<T> : IUnsignedNumOperator<T>, INegateOperator<T> { } public readonly struct IntOperator : ISignedNumOperator<int> { public int MinValue => int.MinValue; public int MaxValue => int.MaxValue; public int Add(int x, int y) => x + y; public int Subtract(int x, int y) => x - y; public int Multiply(int x, int y) => x * y; public int Divide(int x, int y) => x / y; public int Modulo(int x, int y) => x % y; public int Negate(int x) => -x; public int Increment(int x) => ++x; public int Decrement(int x) => --x; public bool GreaterThan(int x, int y) => x > y; public bool GreaterThanOrEqual(int x, int y) => x >= y; public bool LessThan(int x, int y) => x < y; public bool LessThanOrEqual(int x, int y) => x <= y; public int Compare(int x, int y) => x.CompareTo(y); public bool Equals(int x, int y) => x == y; public int GetHashCode(int obj) => obj.GetHashCode(); } public readonly struct LongOperator : ISignedNumOperator<long> { public long MinValue => long.MinValue; public long MaxValue => long.MaxValue; public long Add(long x, long y) => x + y; public long Subtract(long x, long y) => x - y; public long Multiply(long x, long y) => x * y; public long Divide(long x, long y) => x / y; public long Modulo(long x, long y) => x % y; public long Negate(long x) => -x; public long Increment(long x) => ++x; public long Decrement(long x) => --x; public bool GreaterThan(long x, long y) => x > y; public bool GreaterThanOrEqual(long x, long y) => x >= y; public bool LessThan(long x, long y) => x < y; public bool LessThanOrEqual(long x, long y) => x <= y; public int Compare(long x, long y) => x.CompareTo(y); public bool Equals(long x, long y) => x == y; public int GetHashCode(long obj) => obj.GetHashCode(); } public readonly struct UIntOperator : IUnsignedNumOperator<uint> { public uint MinValue => uint.MinValue; public uint MaxValue => uint.MaxValue; public uint Add(uint x, uint y) => x + y; public uint Subtract(uint x, uint y) => x - y; public uint Multiply(uint x, uint y) => x * y; public uint Divide(uint x, uint y) => x / y; public uint Modulo(uint x, uint y) => x % y; public uint Increment(uint x) => ++x; public uint Decrement(uint x) => --x; public bool GreaterThan(uint x, uint y) => x > y; public bool GreaterThanOrEqual(uint x, uint y) => x >= y; public bool LessThan(uint x, uint y) => x < y; public bool LessThanOrEqual(uint x, uint y) => x <= y; public int Compare(uint x, uint y) => x.CompareTo(y); public bool Equals(uint x, uint y) => x == y; public int GetHashCode(uint obj) => obj.GetHashCode(); } public readonly struct ULongOperator : IUnsignedNumOperator<ulong> { public ulong MinValue => ulong.MinValue; public ulong MaxValue => ulong.MaxValue; public ulong Add(ulong x, ulong y) => x + y; public ulong Subtract(ulong x, ulong y) => x - y; public ulong Multiply(ulong x, ulong y) => x * y; public ulong Divide(ulong x, ulong y) => x / y; public ulong Modulo(ulong x, ulong y) => x % y; public ulong Increment(ulong x) => ++x; public ulong Decrement(ulong x) => --x; public bool GreaterThan(ulong x, ulong y) => x > y; public bool GreaterThanOrEqual(ulong x, ulong y) => x >= y; public bool LessThan(ulong x, ulong y) => x < y; public bool LessThanOrEqual(ulong x, ulong y) => x <= y; public int Compare(ulong x, ulong y) => x.CompareTo(y); public bool Equals(ulong x, ulong y) => x == y; public int GetHashCode(ulong obj) => obj.GetHashCode(); } public readonly struct DoubleOperator : ISignedNumOperator<double> { public double MinValue => double.MinValue; public double MaxValue => double.MaxValue; public double Add(double x, double y) => x + y; public double Subtract(double x, double y) => x - y; public double Multiply(double x, double y) => x * y; public double Divide(double x, double y) => x / y; public double Modulo(double x, double y) => x % y; public double Negate(double x) => -x; public double Increment(double x) => ++x; public double Decrement(double x) => --x; public bool GreaterThan(double x, double y) => x > y; public bool GreaterThanOrEqual(double x, double y) => x >= y; public bool LessThan(double x, double y) => x < y; public bool LessThanOrEqual(double x, double y) => x <= y; public int Compare(double x, double y) => x.CompareTo(y); public bool Equals(double x, double y) => x == y; public int GetHashCode(double obj) => obj.GetHashCode(); } } "),
new AclFileInfo(@"Math/MathLib.cs", new string[] { @"AtCoder.MathLib", @"AtCoder.MathLib.FFTMod1", @"AtCoder.MathLib.FFTMod2", @"AtCoder.MathLib.FFTMod3" }, new string[] { @"using System;", @"using System.Diagnostics;", @"using System.Linq;", @"using AtCoder.Internal;" }, new string[] { @"Math/Internal/Barrett.cs", @"Math/Internal/InternalMath.cs", @"Math/ModInt.cs", @"Bit/Internal/InternalBit.cs", @"Math/Internal/Butterfly.cs" }, @"namespace AtCoder { public static class MathLib { public static long PowMod(long x, long n, int m) { Debug.Assert(0 <= n && 1 <= m); if (m == 1) return 0; Barrett barrett = new Barrett((uint)m); uint r = 1, y = (uint)InternalMath.SafeMod(x, m); while (0 < n) { if ((n & 1) != 0) r = barrett.Mul(r, y); y = barrett.Mul(y, y); n >>= 1; } return r; } public static long InvMod(long x, int m) { Debug.Assert(1 <= m); var (g, res) = InternalMath.InvGCD(x, m); Debug.Assert(g == 1); return res; } public static (long, long) CRT(long[] r, long[] m) { Debug.Assert(r.Length == m.Length); long r0 = 0, m0 = 1; for (int i = 0; i < m.Length; i++) { Debug.Assert(1 <= m[i]); long r1 = InternalMath.SafeMod(r[i], m[i]); long m1 = m[i]; if (m0 < m1) { (r0, r1) = (r1, r0); (m0, m1) = (m1, m0); } if (m0 % m1 == 0) { if (r0 % m1 != r1) return (0, 0); continue; } var (g, im) = InternalMath.InvGCD(m0, m1); long u1 = (m1 / g); if ((r1 - r0) % g != 0) return (0, 0); long x = (r1 - r0) / g % u1 * im % u1; r0 += x * m0; m0 *= u1; if (r0 < 0) r0 += m0; } return (r0, m0); } public static long FloorSum(long n, long m, long a, long b) { long ans = 0; while (true) { if (a >= m) { ans += (n - 1) * n * (a / m) / 2; a %= m; } if (b >= m) { ans += n * (b / m); b %= m; } long yMax = (a * n + b) / m; long xMax = yMax * m - b; if (yMax == 0) return ans; ans += (n - (xMax + a - 1) / a) * yMax; (n, m, a, b) = (yMax, a, m, (a - xMax % a) % a); } } public static int[] Convolution(int[] a, int[] b) => Convolution<Mod998244353>(a, b); public static uint[] Convolution(uint[] a, uint[] b) => Convolution<Mod998244353>(a, b); public static long[] Convolution(long[] a, long[] b) => Convolution<Mod998244353>(a, b); public static ulong[] Convolution(ulong[] a, ulong[] b) => Convolution<Mod998244353>(a, b); public static int[] Convolution<TMod>(int[] a, int[] b) where TMod : struct, IStaticMod { var n = a.Length; var m = b.Length; if (n == 0 || m == 0) { return Array.Empty<int>(); } if (Math.Min(n, m) <= 60) { var c = ConvolutionNaive<TMod>(a.Select(ai => new StaticModInt<TMod>(ai)).ToArray(), b.Select(bi => new StaticModInt<TMod>(bi)).ToArray()); return c.Select(ci => ci.Value).ToArray(); } else { int z = 1 << Internal.InternalBit.CeilPow2(n + m - 1); var aTemp = new StaticModInt<TMod>[z]; for (int i = 0; i < a.Length; i++) { aTemp[i] = new StaticModInt<TMod>(a[i]); } var bTemp = new StaticModInt<TMod>[z]; for (int i = 0; i < b.Length; i++) { bTemp[i] = new StaticModInt<TMod>(b[i]); } var c = Convolution<TMod>(aTemp, bTemp, n, m, z)[0..(n + m - 1)]; var result = new int[c.Length]; for (int i = 0; i < result.Length; i++) { result[i] = c[i].Value; } return result; } } public static uint[] Convolution<TMod>(uint[] a, uint[] b) where TMod : struct, IStaticMod { var n = a.Length; var m = b.Length; if (n == 0 || m == 0) { return Array.Empty<uint>(); } if (Math.Min(n, m) <= 60) { var c = ConvolutionNaive<TMod>(a.Select(ai => new StaticModInt<TMod>(ai)).ToArray(), b.Select(bi => new StaticModInt<TMod>(bi)).ToArray()); return c.Select(ci => (uint)ci.Value).ToArray(); } else { int z = 1 << Internal.InternalBit.CeilPow2(n + m - 1); var aTemp = new StaticModInt<TMod>[z]; for (int i = 0; i < a.Length; i++) { aTemp[i] = new StaticModInt<TMod>(a[i]); } var bTemp = new StaticModInt<TMod>[z]; for (int i = 0; i < b.Length; i++) { bTemp[i] = new StaticModInt<TMod>(b[i]); } var c = Convolution<TMod>(aTemp, bTemp, n, m, z)[0..(n + m - 1)]; var result = new uint[c.Length]; for (int i = 0; i < result.Length; i++) { result[i] = (uint)c[i].Value; } return result; } } public static long[] Convolution<TMod>(long[] a, long[] b) where TMod : struct, IStaticMod { var n = a.Length; var m = b.Length; if (n == 0 || m == 0) { return Array.Empty<long>(); } if (Math.Min(n, m) <= 60) { var c = ConvolutionNaive<TMod>(a.Select(ai => new StaticModInt<TMod>(ai)).ToArray(), b.Select(bi => new StaticModInt<TMod>(bi)).ToArray()); return c.Select(ci => (long)ci.Value).ToArray(); } else { int z = 1 << Internal.InternalBit.CeilPow2(n + m - 1); var aTemp = new StaticModInt<TMod>[z]; for (int i = 0; i < a.Length; i++) { aTemp[i] = new StaticModInt<TMod>(a[i]); } var bTemp = new StaticModInt<TMod>[z]; for (int i = 0; i < b.Length; i++) { bTemp[i] = new StaticModInt<TMod>(b[i]); } var c = Convolution<TMod>(aTemp, bTemp, n, m, z)[0..(n + m - 1)]; var result = new long[c.Length]; for (int i = 0; i < result.Length; i++) { result[i] = c[i].Value; } return result; } } public static ulong[] Convolution<TMod>(ulong[] a, ulong[] b) where TMod : struct, IStaticMod { var n = a.Length; var m = b.Length; if (n == 0 || m == 0) { return Array.Empty<ulong>(); } if (Math.Min(n, m) <= 60) { var c = ConvolutionNaive<TMod>(a.Select(TakeMod).ToArray(), b.Select(TakeMod).ToArray()); return c.Select(ci => (ulong)ci.Value).ToArray(); } else { int z = 1 << Internal.InternalBit.CeilPow2(n + m - 1); var aTemp = new StaticModInt<TMod>[z]; for (int i = 0; i < a.Length; i++) { aTemp[i] = TakeMod(a[i]); } var bTemp = new StaticModInt<TMod>[z]; for (int i = 0; i < b.Length; i++) { bTemp[i] = TakeMod(b[i]); } var c = Convolution<TMod>(aTemp, bTemp, n, m, z)[0..(n + m - 1)]; var result = new ulong[c.Length]; for (int i = 0; i < result.Length; i++) { result[i] = (ulong)c[i].Value; } return result; } StaticModInt<TMod> TakeMod(ulong x) => StaticModInt<TMod>.Raw((int)(x % default(TMod).Mod)); } public static StaticModInt<TMod>[] Convolution<TMod>(StaticModInt<TMod>[] a, StaticModInt<TMod>[] b) where TMod : struct, IStaticMod { var temp = Convolution((ReadOnlySpan<StaticModInt<TMod>>)a, b); return temp.ToArray(); } public static Span<StaticModInt<TMod>> Convolution<TMod>(ReadOnlySpan<StaticModInt<TMod>> a, ReadOnlySpan<StaticModInt<TMod>> b) where TMod : struct, IStaticMod { var n = a.Length; var m = b.Length; if (n == 0 || m == 0) { return Array.Empty<StaticModInt<TMod>>(); } if (Math.Min(n, m) <= 60) { return ConvolutionNaive(a, b); } int z = 1 << Internal.InternalBit.CeilPow2(n + m - 1); var aTemp = new StaticModInt<TMod>[z]; a.CopyTo(aTemp); var bTemp = new StaticModInt<TMod>[z]; b.CopyTo(bTemp); return Convolution(aTemp.AsSpan(), bTemp.AsSpan(), n, m, z); } private static Span<StaticModInt<TMod>> Convolution<TMod>(Span<StaticModInt<TMod>> a, Span<StaticModInt<TMod>> b, int n, int m, int z) where TMod : struct, IStaticMod { Internal.Butterfly<TMod>.Calculate(a); Internal.Butterfly<TMod>.Calculate(b); for (int i = 0; i < a.Length; i++) { a[i] *= b[i]; } Internal.Butterfly<TMod>.CalculateInv(a); var result = a[0..(n + m - 1)]; var iz = new StaticModInt<TMod>(z).Inv(); foreach (ref var r in result) { r *= iz; } return result; } public static long[] ConvolutionLong(ReadOnlySpan<long> a, ReadOnlySpan<long> b) { unchecked { var n = a.Length; var m = b.Length; if (n == 0 || m == 0) { return Array.Empty<long>(); } const ulong Mod1 = 754974721; const ulong Mod2 = 167772161; const ulong Mod3 = 469762049; const ulong M2M3 = Mod2 * Mod3; const ulong M1M3 = Mod1 * Mod3; const ulong M1M2 = Mod1 * Mod2; const ulong M1M2M3 = Mod1 * Mod2 * Mod3; ulong i1 = (ulong)Internal.InternalMath.InvGCD((long)M2M3, (long)Mod1).Item2; ulong i2 = (ulong)Internal.InternalMath.InvGCD((long)M1M3, (long)Mod2).Item2; ulong i3 = (ulong)Internal.InternalMath.InvGCD((long)M1M2, (long)Mod3).Item2; var c1 = Convolution<FFTMod1>(a, b); var c2 = Convolution<FFTMod2>(a, b); var c3 = Convolution<FFTMod3>(a, b); var c = new long[n + m - 1]; Span<ulong> offset = stackalloc ulong[] { 0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3 }; for (int i = 0; i < c.Length; i++) { ulong x = 0; x += (c1[i] * i1) % Mod1 * M2M3; x += (c2[i] * i2) % Mod2 * M1M3; x += (c3[i] * i3) % Mod3 * M1M2; long diff = (long)c1[i] - Internal.InternalMath.SafeMod((long)x, (long)Mod1); if (diff < 0) { diff += (long)Mod1; } x -= offset[(int)(diff % offset.Length)]; c[i] = (long)x; } return c; } ulong[] Convolution<TMod>(ReadOnlySpan<long> a, ReadOnlySpan<long> b) where TMod : struct, IStaticMod { int z = 1 << Internal.InternalBit.CeilPow2(a.Length + b.Length - 1); var aTemp = new StaticModInt<TMod>[z]; for (int i = 0; i < a.Length; i++) { aTemp[i] = new StaticModInt<TMod>(a[i]); } var bTemp = new StaticModInt<TMod>[z]; for (int i = 0; i < b.Length; i++) { bTemp[i] = new StaticModInt<TMod>(b[i]); } var c = AtCoder.MathLib.Convolution<TMod>(aTemp, bTemp, a.Length, b.Length, z); var result = new ulong[c.Length]; for (int i = 0; i < result.Length; i++) { result[i] = (ulong)c[i].Value; } return result; } } private static StaticModInt<TMod>[] ConvolutionNaive<TMod>(ReadOnlySpan<StaticModInt<TMod>> a, ReadOnlySpan<StaticModInt<TMod>> b) where TMod : struct, IStaticMod { if (a.Length < b.Length) { var temp = a; a = b; b = temp; } var ans = new StaticModInt<TMod>[a.Length + b.Length - 1]; for (int i = 0; i < a.Length; i++) { for (int j = 0; j < b.Length; j++) { ans[i + j] += a[i] * b[j]; } } return ans; } private readonly struct FFTMod1 : IStaticMod { public uint Mod => 754974721; public bool IsPrime => true; } private readonly struct FFTMod2 : IStaticMod { public uint Mod => 167772161; public bool IsPrime => true; } private readonly struct FFTMod3 : IStaticMod { public uint Mod => 469762049; public bool IsPrime => true; } } } "),
new AclFileInfo(@"Math/ModInt.cs", new string[] { @"AtCoder.IStaticMod", @"AtCoder.Mod1000000007", @"AtCoder.Mod998244353", @"AtCoder.IDynamicModID", @"AtCoder.ModID0", @"AtCoder.ModID1", @"AtCoder.ModID2", @"AtCoder.StaticModIntOperator<T>", @"AtCoder.StaticModInt<T>", @"AtCoder.DynamicModInt<T>" }, new string[] { @"using System.Collections.Generic;", @"using System.Diagnostics;" }, new string[] { @"Algebra/Operators.cs", @"Math/Internal/InternalMath.cs", @"Math/Internal/Barrett.cs" }, @"namespace AtCoder { public interface IStaticMod { uint Mod { get; } bool IsPrime { get; } } public readonly struct Mod1000000007 : IStaticMod { public uint Mod => 1000000007; public bool IsPrime => true; } public readonly struct Mod998244353 : IStaticMod { public uint Mod => 998244353; public bool IsPrime => true; } public interface IDynamicModID { } public readonly struct ModID0 : IDynamicModID { } public readonly struct ModID1 : IDynamicModID { } public readonly struct ModID2 : IDynamicModID { } public readonly struct StaticModIntOperator<T> : IAddOperator<StaticModInt<T>>, ISubtractOperator<StaticModInt<T>>, IMultiplyOperator<StaticModInt<T>>, IDivideOperator<StaticModInt<T>>, IIncrementOperator<StaticModInt<T>>, IDecrementOperator<StaticModInt<T>>, INegateOperator<StaticModInt<T>>, IEqualityComparer<StaticModInt<T>> where T : struct, IStaticMod { public StaticModInt<T> Add(StaticModInt<T> x, StaticModInt<T> y) => x + y; public StaticModInt<T> Subtract(StaticModInt<T> x, StaticModInt<T> y) => x - y; public StaticModInt<T> Multiply(StaticModInt<T> x, StaticModInt<T> y) => x * y; public StaticModInt<T> Divide(StaticModInt<T> x, StaticModInt<T> y) => x / y; public StaticModInt<T> Negate(StaticModInt<T> x) => -x; public StaticModInt<T> Increment(StaticModInt<T> x) => ++x; public StaticModInt<T> Decrement(StaticModInt<T> x) => --x; public bool Equals(StaticModInt<T> x, StaticModInt<T> y) => x == y; public int GetHashCode(StaticModInt<T> obj) => obj.GetHashCode(); } public readonly struct StaticModInt<T> where T : struct, IStaticMod { private readonly uint _v; public int Value => (int)_v; public static int Mod => (int)default(T).Mod; public static StaticModInt<T> Raw(int v) { var u = unchecked((uint)v); Debug.Assert(u < Mod); return new StaticModInt<T>(u); } public StaticModInt(long v) : this(Round(v)) { } private StaticModInt(uint v) => _v = v; private static uint Round(long v) { var x = v % default(T).Mod; if (x < 0) { x += default(T).Mod; } return (uint)x; } public static StaticModInt<T> operator ++(StaticModInt<T> value) { var v = value._v + 1; if (v == default(T).Mod) { v = 0; } return new StaticModInt<T>(v); } public static StaticModInt<T> operator --(StaticModInt<T> value) { var v = value._v; if (v == 0) { v = default(T).Mod; } return new StaticModInt<T>(v - 1); } public static StaticModInt<T> operator +(StaticModInt<T> lhs, StaticModInt<T> rhs) { var v = lhs._v + rhs._v; if (v >= default(T).Mod) { v -= default(T).Mod; } return new StaticModInt<T>(v); } public static StaticModInt<T> operator -(StaticModInt<T> lhs, StaticModInt<T> rhs) { unchecked { var v = lhs._v - rhs._v; if (v >= default(T).Mod) { v += default(T).Mod; } return new StaticModInt<T>(v); } } public static StaticModInt<T> operator *(StaticModInt<T> lhs, StaticModInt<T> rhs) { return new StaticModInt<T>((uint)((ulong)lhs._v * rhs._v % default(T).Mod)); } public static StaticModInt<T> operator /(StaticModInt<T> lhs, StaticModInt<T> rhs) => lhs * rhs.Inv(); public static StaticModInt<T> operator +(StaticModInt<T> value) => value; public static StaticModInt<T> operator -(StaticModInt<T> value) => new StaticModInt<T>() - value; public static bool operator ==(StaticModInt<T> lhs, StaticModInt<T> rhs) => lhs._v == rhs._v; public static bool operator !=(StaticModInt<T> lhs, StaticModInt<T> rhs) => lhs._v != rhs._v; public static implicit operator StaticModInt<T>(int value) => new StaticModInt<T>(value); public static implicit operator StaticModInt<T>(long value) => new StaticModInt<T>(value); public StaticModInt<T> Pow(long n) { Debug.Assert(0 <= n); var x = this; var r = new StaticModInt<T>(1u); while (n > 0) { if ((n & 1) > 0) { r *= x; } x *= x; n >>= 1; } return r; } public StaticModInt<T> Inv() { if (default(T).IsPrime) { Debug.Assert(_v > 0); return Pow(default(T).Mod - 2); } else { var (g, x) = Internal.InternalMath.InvGCD(_v, default(T).Mod); Debug.Assert(g == 1); return new StaticModInt<T>(x); } } public override string ToString() => _v.ToString(); public override bool Equals(object obj) => obj is StaticModInt<T> && this == (StaticModInt<T>)obj; public override int GetHashCode() => _v.GetHashCode(); } public readonly struct DynamicModInt<T> where T : struct, IDynamicModID { private readonly uint _v; private static Internal.Barrett bt; public int Value => (int)_v; public static int Mod { get => (int)bt.Mod; set { Debug.Assert(1 <= value); bt = new Internal.Barrett((uint)value); } } public static DynamicModInt<T> Raw(int v) { var u = unchecked((uint)v); Debug.Assert(bt != null, $""使用前に {nameof(DynamicModInt<T>)}<{nameof(T)}>.{nameof(Mod)} プロパティに mod の値を設定してください。""); Debug.Assert(u < Mod); return new DynamicModInt<T>(u); } public DynamicModInt(long v) : this(Round(v)) { } private DynamicModInt(uint v) => _v = v; private static uint Round(long v) { Debug.Assert(bt != null, $""使用前に {nameof(DynamicModInt<T>)}<{nameof(T)}>.{nameof(Mod)} プロパティに mod の値を設定してください。""); var x = v % bt.Mod; if (x < 0) { x += bt.Mod; } return (uint)x; } public static DynamicModInt<T> operator ++(DynamicModInt<T> value) { var v = value._v + 1; if (v == bt.Mod) { v = 0; } return new DynamicModInt<T>(v); } public static DynamicModInt<T> operator --(DynamicModInt<T> value) { var v = value._v; if (v == 0) { v = bt.Mod; } return new DynamicModInt<T>(v - 1); } public static DynamicModInt<T> operator +(DynamicModInt<T> lhs, DynamicModInt<T> rhs) { var v = lhs._v + rhs._v; if (v >= bt.Mod) { v -= bt.Mod; } return new DynamicModInt<T>(v); } public static DynamicModInt<T> operator -(DynamicModInt<T> lhs, DynamicModInt<T> rhs) { unchecked { var v = lhs._v - rhs._v; if (v >= bt.Mod) { v += bt.Mod; } return new DynamicModInt<T>(v); } } public static DynamicModInt<T> operator *(DynamicModInt<T> lhs, DynamicModInt<T> rhs) { uint z = bt.Mul(lhs._v, rhs._v); return new DynamicModInt<T>(z); } public static DynamicModInt<T> operator /(DynamicModInt<T> lhs, DynamicModInt<T> rhs) => lhs * rhs.Inv(); public static DynamicModInt<T> operator +(DynamicModInt<T> value) => value; public static DynamicModInt<T> operator -(DynamicModInt<T> value) => new DynamicModInt<T>() - value; public static bool operator ==(DynamicModInt<T> lhs, DynamicModInt<T> rhs) => lhs._v == rhs._v; public static bool operator !=(DynamicModInt<T> lhs, DynamicModInt<T> rhs) => lhs._v != rhs._v; public static implicit operator DynamicModInt<T>(int value) => new DynamicModInt<T>(value); public static implicit operator DynamicModInt<T>(long value) => new DynamicModInt<T>(value); public DynamicModInt<T> Pow(long n) { Debug.Assert(0 <= n); var x = this; var r = new DynamicModInt<T>(1u); while (n > 0) { if ((n & 1) > 0) { r *= x; } x *= x; n >>= 1; } return r; } public DynamicModInt<T> Inv() { var (g, x) = Internal.InternalMath.InvGCD(_v, bt.Mod); Debug.Assert(g == 1); return new DynamicModInt<T>(x); } public override string ToString() => _v.ToString(); public override bool Equals(object obj) => obj is DynamicModInt<T> && this == (DynamicModInt<T>)obj; public override int GetHashCode() => _v.GetHashCode(); } } "),
new AclFileInfo(@"Stl/NextPermutasion.cs", new string[] { @"AtCoder.Stl.Global" }, new string[] { @"using System;", @"using System.Collections.Generic;", @"using System.Linq;" }, new string[] {  }, @"namespace AtCoder.Stl { public static class Global { public static IEnumerable<T[]> NextPermutation<T>(IEnumerable<T> orig) where T : IComparable<T> { var arr = orig.ToArray(); while (true) { yield return arr; int i; for (i = arr.Length - 2; i >= 0; i--) if (arr[i].CompareTo(arr[i + 1]) < 0) break; if (i < 0) break; int j; for (j = arr.Length - 1; j >= 0; j--) if (arr[i].CompareTo(arr[j]) < 0) break; (arr[i], arr[j]) = (arr[j], arr[i]); Array.Reverse(arr, i + 1, arr.Length - i - 1); } } } } "),
new AclFileInfo(@"Stl/Set.cs", new string[] { @"AtCoder.Stl.Set<T>", @"AtCoder.Stl.Set<T>.Enumerator", @"AtCoder.Stl.Set<T>.Node" }, new string[] { @"using System;", @"using System.Collections.Generic;", @"using System.Diagnostics;", @"using System.Linq;", @"using System.Numerics;", @"using System.Runtime.CompilerServices;", @"using AtCoder.Util.Internal;" }, new string[] { @"Util/Internal/CollectionDebugView.cs" }, @"namespace AtCoder.Stl { [DebuggerTypeProxy(typeof(CollectionDebugView<>))] [DebuggerDisplay(""Count = {"" + nameof(Count) + ""}"")] public class Set<T> : ICollection<T>, IReadOnlyCollection<T> { internal const string LISENCE = @""
Original is SortedSet<T>

Copyright (c) .NET Foundation and Contributors
Released under the MIT license
https://github.com/dotnet/runtime/blob/master/LICENSE.TXT
""; public bool IsMulti { get; } public T Min { get { if (root == null) return default; var cur = root; while (cur.Left != null) { cur = cur.Left; } return cur.Item; } } public T Max { get { if (root == null) return default; var cur = root; while (cur.Right != null) { cur = cur.Right; } return cur.Item; } } public Node FindNode(T item) { Node current = root; while (current != null) { int order = comparer.Compare(item, current.Item); if (order == 0) return current; current = order < 0 ? current.Left : current.Right; } return null; } public int Index(Node node) { var ret = NodeSize(node.Left); Node prev = node; node = node.Parent; while (prev != root) { if (node.Left != prev) { ret += NodeSize(node.Left) + 1; } prev = node; node = node.Parent; } return ret; } public Node FindByIndex(int index) { var current = root; var currentIndex = current.Size - NodeSize(current.Right) - 1; while (currentIndex != index) { if (currentIndex > index) { current = current.Left; if (current == null) break; currentIndex -= NodeSize(current.Right) + 1; } else { current = current.Right; if (current == null) break; currentIndex += NodeSize(current.Left) + 1; } } return current; } public (Node node, int index) BinarySearch(T item, bool isLowerBound) { Node right = null; Node current = root; if (current == null) return (null, -1); int ri = -1; int ci = NodeSize(current.Left); while (true) { var order = comparer.Compare(item, current.Item); if (order < 0 || (isLowerBound && order == 0)) { right = current; ri = ci; current = current.Left; if (current != null) ci -= NodeSize(current.Right) + 1; else break; } else { current = current.Right; if (current != null) ci += NodeSize(current.Left) + 1; else break; } } return (right, ri); } public Node FindNodeLowerBound(T item) => BinarySearch(item, true).node; public Node FindNodeUpperBound(T item) => BinarySearch(item, false).node; public T LowerBoundItem(T item) => BinarySearch(item, true).node.Item; public T UpperBoundItem(T item) => BinarySearch(item, false).node.Item; public int LowerBoundIndex(T item) => BinarySearch(item, true).index; public int UpperBoundIndex(T item) => BinarySearch(item, false).index; public IEnumerable<T> Reversed() { var e = new Enumerator(this, true, null); while (e.MoveNext()) yield return e.Current; } public IEnumerable<T> Enumerate(Node from) => Enumerate(from, false); public IEnumerable<T> Enumerate(Node from, bool reverse) { if (from == null) yield break; var e = new Enumerator(this, reverse, from); while (e.MoveNext()) yield return e.Current; } public Set(bool isMulti = false) : this(Comparer<T>.Default, isMulti) { } public Set(IEnumerable<T> collection, bool isMulti = false) : this(collection, Comparer<T>.Default, isMulti) { } public Set(IComparer<T> comparer, bool isMulti = false) { this.comparer = comparer; this.IsMulti = isMulti; } public Set(IEnumerable<T> collection, IComparer<T> comparer, bool isMulti = false) { this.comparer = comparer; var arr = InitArray(collection); this.root = ConstructRootFromSortedArray(arr, 0, arr.Length - 1, null); this.IsMulti = isMulti; } protected T[] InitArray(IEnumerable<T> collection) { T[] arr; if (this.IsMulti) { arr = collection.ToArray(); Array.Sort(arr, this.comparer); } else { var list = new List<T>(collection); list.Sort(this.comparer); for (int i = list.Count - 1; i > 0; i--) if (this.comparer.Compare(list[i - 1], list[i]) == 0) list.RemoveAt(i); arr = list.ToArray(); } return arr; } public int Count => NodeSize(root); protected static int NodeSize(Node node) => node == null ? 0 : node.Size; protected readonly IComparer<T> comparer; bool ICollection<T>.IsReadOnly => false; Node root; static Node ConstructRootFromSortedArray(T[] arr, int startIndex, int endIndex, Node redNode) { int size = endIndex - startIndex + 1; Node root; switch (size) { case 0: return null; case 1: root = new Node(arr[startIndex], false); if (redNode != null) { root.Left = redNode; } break; case 2: root = new Node(arr[startIndex], false) { Right = new Node(arr[endIndex], true) }; if (redNode != null) { root.Left = redNode; } break; case 3: root = new Node(arr[startIndex + 1], false) { Left = new Node(arr[startIndex], false), Right = new Node(arr[endIndex], false) }; if (redNode != null) { root.Left.Left = redNode; } break; default: int midpt = ((startIndex + endIndex) / 2); root = new Node(arr[midpt], false) { Left = ConstructRootFromSortedArray(arr, startIndex, midpt - 1, redNode), Right = size % 2 == 0 ? ConstructRootFromSortedArray(arr, midpt + 2, endIndex, new Node(arr[midpt + 1], true)) : ConstructRootFromSortedArray(arr, midpt + 1, endIndex, null) }; break; } return root; } void ICollection<T>.Add(T item) => this.Add(item); public bool Add(T item) { if (root == null) { root = new Node(item, false); return true; } Node current = root; Node parent = null; Node grandParent = null; Node greatGrandParent = null; int order = 0; while (current != null) { order = comparer.Compare(item, current.Item); if (order == 0 && !this.IsMulti) { current.Item = item; root.IsRed = false; return false; } if (Is4Node(current)) { Split4Node(current); if (IsNonNullRed(parent) == true) { InsertionBalance(current, ref parent, grandParent, greatGrandParent); } } greatGrandParent = grandParent; grandParent = parent; parent = current; current = (order < 0) ? current.Left : current.Right; } Node node = new Node(item, true); if (order >= 0) parent.Right = node; else parent.Left = node; if (parent.IsRed) InsertionBalance(node, ref parent, grandParent, greatGrandParent); root.IsRed = false; return true; } public bool Remove(T item) { if (root == null) return false; Node current = root; Node parent = null; Node grandParent = null; Node match = null; Node parentOfMatch = null; bool foundMatch = false; while (current != null) { if (Is2Node(current)) { if (parent == null) { current.IsRed = true; } else { Node sibling = GetSibling(current, parent); if (sibling.IsRed) { if (parent.Right == sibling) RotateLeft(parent); else RotateRight(parent); parent.IsRed = true; sibling.IsRed = false; ReplaceChildOrRoot(grandParent, parent, sibling); grandParent = sibling; if (parent == match) parentOfMatch = sibling; sibling = (parent.Left == current) ? parent.Right : parent.Left; } if (Is2Node(sibling)) { Merge2Nodes(parent); } else { TreeRotation rotation = GetRotation(parent, current, sibling); Node newGrandParent = Rotate(parent, rotation); newGrandParent.IsRed = parent.IsRed; parent.IsRed = false; current.IsRed = true; ReplaceChildOrRoot(grandParent, parent, newGrandParent); if (parent == match) { parentOfMatch = newGrandParent; } } } } int order = foundMatch ? -1 : comparer.Compare(item, current.Item); if (order == 0) { foundMatch = true; match = current; parentOfMatch = parent; } grandParent = parent; parent = current; current = order < 0 ? current.Left : current.Right; } if (match != null) { ReplaceNode(match, parentOfMatch, parent, grandParent); } if (root != null) { root.IsRed = false; } return foundMatch; } public void Clear() { root = null; } public bool Contains(T item) => FindNode(item) != null; public void CopyTo(T[] array, int arrayIndex) { foreach (var item in this) array[arrayIndex++] = item; } public Enumerator GetEnumerator() => new Enumerator(this); IEnumerator<T> IEnumerable<T>.GetEnumerator() => new Enumerator(this); System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => new Enumerator(this); static bool Is2Node(Node node) => IsNonNullBlack(node) && IsNullOrBlack(node.Left) && IsNullOrBlack(node.Right); static bool Is4Node(Node node) => IsNonNullRed(node.Left) && IsNonNullRed(node.Right); static bool IsNonNullRed(Node node) => node != null && node.IsRed; static bool IsNonNullBlack(Node node) => node != null && !node.IsRed; static bool IsNullOrBlack(Node node) => node == null || !node.IsRed; void ReplaceNode(Node match, Node parentOfMatch, Node succesor, Node parentOfSuccesor) { if (succesor == match) { succesor = match.Left; } else { if (succesor.Right != null) { succesor.Right.IsRed = false; } if (parentOfSuccesor != match) { parentOfSuccesor.Left = succesor.Right; succesor.Right = match.Right; } succesor.Left = match.Left; } if (succesor != null) { succesor.IsRed = match.IsRed; } ReplaceChildOrRoot(parentOfMatch, match, succesor); } static void Merge2Nodes(Node parent) { parent.IsRed = false; parent.Left.IsRed = true; parent.Right.IsRed = true; } static void Split4Node(Node node) { node.IsRed = true; node.Left.IsRed = false; node.Right.IsRed = false; } static Node GetSibling(Node node, Node parent) { return parent.Left == node ? parent.Right : parent.Left; } void InsertionBalance(Node current, ref Node parent, Node grandParent, Node greatGrandParent) { bool parentIsOnRight = grandParent.Right == parent; bool currentIsOnRight = parent.Right == current; Node newChildOfGreatGrandParent; if (parentIsOnRight == currentIsOnRight) { newChildOfGreatGrandParent = currentIsOnRight ? RotateLeft(grandParent) : RotateRight(grandParent); } else { newChildOfGreatGrandParent = currentIsOnRight ? RotateLeftRight(grandParent) : RotateRightLeft(grandParent); parent = greatGrandParent; } grandParent.IsRed = true; newChildOfGreatGrandParent.IsRed = false; ReplaceChildOrRoot(greatGrandParent, grandParent, newChildOfGreatGrandParent); } static Node Rotate(Node node, TreeRotation rotation) { switch (rotation) { case TreeRotation.Right: node.Left.Left.IsRed = false; return RotateRight(node); case TreeRotation.Left: node.Right.Right.IsRed = false; return RotateLeft(node); case TreeRotation.RightLeft: return RotateRightLeft(node); case TreeRotation.LeftRight: return RotateLeftRight(node); default: throw new InvalidOperationException(); } } static Node RotateLeft(Node node) { Node child = node.Right; node.Right = child.Left; child.Left = node; return child; } static Node RotateLeftRight(Node node) { Node child = node.Left; Node grandChild = child.Right; node.Left = grandChild.Right; grandChild.Right = node; child.Right = grandChild.Left; grandChild.Left = child; return grandChild; } static Node RotateRight(Node node) { Node child = node.Left; node.Left = child.Right; child.Right = node; return child; } static Node RotateRightLeft(Node node) { Node child = node.Right; Node grandChild = child.Left; node.Right = grandChild.Left; grandChild.Left = node; child.Left = grandChild.Right; grandChild.Right = child; return grandChild; } void ReplaceChildOrRoot(Node parent, Node child, Node newChild) { if (parent != null) { if (parent.Left == child) { parent.Left = newChild; } else { parent.Right = newChild; } } else { root = newChild; } } static TreeRotation GetRotation(Node parent, Node current, Node sibling) { if (IsNonNullRed(sibling.Left)) { if (parent.Left == current) { return TreeRotation.RightLeft; } return TreeRotation.Right; } else { if (parent.Left == current) { return TreeRotation.Left; } return TreeRotation.LeftRight; } } public struct Enumerator : IEnumerator<T> { Set<T> tree; Stack<Node> stack; Node current; bool reverse; internal Enumerator(Set<T> set) : this(set, false, null) { } internal Enumerator(Set<T> set, bool reverse, Node startNode) { tree = set; stack = new Stack<Node>(2 * Log2(tree.Count + 1)); current = null; this.reverse = reverse; if (startNode == null) IntializeAll(); else Intialize(startNode); } void IntializeAll() { var node = tree.root; while (node != null) { var next = reverse ? node.Right : node.Left; stack.Push(node); node = next; } } void Intialize(Node startNode) { if (startNode == null) throw new InvalidOperationException(nameof(startNode) + ""is null""); current = null; var node = startNode; var list = new List<Node>(Log2(tree.Count + 1)); var comparer = tree.comparer; if (reverse) { while (node != null) { list.Add(node); var parent = node.Parent; if (parent == null || parent.Left == node) { node = parent; break; } node = parent; } while (node != null) { var parent = node.Parent; if (parent == null || parent.Right == node) { node = parent; break; } node = parent; } while (node != null) { if (comparer.Compare(startNode.Item, node.Item) >= 0) list.Add(node); node = node.Parent; } } else { while (node != null) { list.Add(node); var parent = node.Parent; if (parent == null || parent.Right == node) { node = parent; break; } node = parent; } while (node != null) { var parent = node.Parent; if (parent == null || parent.Left == node) { node = parent; break; } node = parent; } while (node != null) { if (comparer.Compare(startNode.Item, node.Item) <= 0) list.Add(node); node = node.Parent; } } list.Reverse(); foreach (var n in list) stack.Push(n); } [MethodImpl(MethodImplOptions.AggressiveInlining)] static int Log2(int num) => BitOperations.Log2((uint)num) + 1; public T Current => current == null ? default : current.Item; public bool MoveNext() { if (stack.Count == 0) { current = null; return false; } current = stack.Pop(); var node = reverse ? current.Left : current.Right; while (node != null) { var next = reverse ? node.Right : node.Left; stack.Push(node); node = next; } return true; } object System.Collections.IEnumerator.Current => this.Current; public void Dispose() { } public void Reset() => throw new NotSupportedException(); } public class Node { public bool IsRed; public T Item; public Node Parent { get; private set; } Node _left; public Node Left { get { return _left; } set { _left = value; if (value != null) value.Parent = this; for (var cur = this; cur != null; cur = cur.Parent) { if (!cur.UpdateSize()) break; if (cur.Parent != null && cur.Parent.Left != cur && cur.Parent.Right != cur) { cur.Parent = null; break; } } } } Node _right; public Node Right { get { return _right; } set { _right = value; if (value != null) value.Parent = this; for (var cur = this; cur != null; cur = cur.Parent) { if (!cur.UpdateSize()) break; if (cur.Parent != null && cur.Parent.Left != cur && cur.Parent.Right != cur) { cur.Parent = null; break; } } } } public int Size { get; private set; } = 1; public Node(T item, bool isRed) { this.Item = item; this.IsRed = isRed; } public bool UpdateSize() { var oldsize = this.Size; var size = 1; if (Left != null) size += Left.Size; if (Right != null) size += Right.Size; this.Size = size; return oldsize != size; } public override string ToString() => $""Size = {Size}, Item = {Item}""; } enum TreeRotation : byte { Left = 1, Right = 2, RightLeft = 3, LeftRight = 4, } } } "),
new AclFileInfo(@"Stl/PriorityQueue.cs", new string[] { @"AtCoder.Stl.PriorityQueue<T>", @"AtCoder.Stl.PriorityQueue<TKey, TValue>", @"AtCoder.Stl.PriorityQueue<TKey, TValue>.KeyComparer" }, new string[] { @"using System;", @"using System.Collections.Generic;" }, new string[] {  }, @"namespace AtCoder.Stl { [System.Diagnostics.DebuggerDisplay(""Count = {"" + nameof(Count) + ""}"")] public class PriorityQueue<T> { protected readonly List<T> data; protected readonly IComparer<T> comparer; public PriorityQueue() : this(Comparer<T>.Default) { } public PriorityQueue(int capacity) : this(capacity, Comparer<T>.Default) { } public PriorityQueue(IComparer<T> comparer) { this.data = new List<T>(); this.comparer = comparer; } public PriorityQueue(int capacity, IComparer<T> comparer) { this.data = new List<T>(capacity); this.comparer = comparer; } [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)] public int Count => data.Count; public T Peek => data[0]; public void Add(T value) { data.Add(value); UpdateUp(data.Count - 1); } public T Dequeue() { var res = data[0]; data[0] = data[^1]; data.RemoveAt(data.Count - 1); UpdateDown(0); return res; } void UpdateUp(int i) { if (i > 0) { var p = (i - 1) >> 1; if (comparer.Compare(data[i], data[p]) < 0) { (data[p], data[i]) = (data[i], data[p]); UpdateUp(p); } } } void UpdateDown(int i) { var n = data.Count; var child = 2 * i + 1; if (child < n) { if (child != n - 1 && comparer.Compare(data[child], data[child + 1]) > 0) child++; if (comparer.Compare(data[i], data[child]) > 0) { (data[child], data[i]) = (data[i], data[child]); UpdateDown(child); } } } public void Clear() => data.Clear(); [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.RootHidden)] T[] Items { get { var arr = data.ToArray(); Array.Sort(arr, comparer); return arr; } } } public class PriorityQueue<TKey, TValue> : PriorityQueue<KeyValuePair<TKey, TValue>> { class KeyComparer : IComparer<KeyValuePair<TKey, TValue>> { public readonly IComparer<TKey> comparer; public KeyComparer(IComparer<TKey> comparer) { this.comparer = comparer; } public int Compare(KeyValuePair<TKey, TValue> x, KeyValuePair<TKey, TValue> y) => comparer.Compare(x.Key, y.Key); } public PriorityQueue() : this(Comparer<TKey>.Default) { } public PriorityQueue(int capacity) : this(capacity, Comparer<TKey>.Default) { } public PriorityQueue(IComparer<TKey> comparer) : base(new KeyComparer(comparer)) { } public PriorityQueue(int capacity, IComparer<TKey> comparer) : base(capacity, new KeyComparer(comparer)) { } public void Add(TKey key, TValue value) => Add(new KeyValuePair<TKey, TValue>(key, value)); } } "),
new AclFileInfo(@"Stl/Deque.cs", new string[] { @"AtCoder.Stl.Deque<T>", @"AtCoder.Stl.Deque<T>.Enumerator" }, new string[] { @"using System;", @"using System.Collections;", @"using System.Collections.Generic;", @"using AtCoder.Internal;", @"using AtCoder.Util.Internal;" }, new string[] { @"Util/Internal/CollectionDebugView.cs", @"Math/Internal/InternalMath.cs" }, @"namespace AtCoder.Stl { [System.Diagnostics.DebuggerTypeProxy(typeof(CollectionDebugView<>))] [System.Diagnostics.DebuggerDisplay(""Count = {"" + nameof(Count) + ""}"")] class Deque<T> : IEnumerable<T>, IReadOnlyCollection<T>, ICollection<T> { T[] data; int mask; int head; int tail; public Deque() : this(8) { } public Deque(int capacity) { if (capacity <= 8) capacity = 8; else capacity = 1 << (InternalMath.CeilPow2(capacity)); data = new T[capacity]; mask = capacity - 1; } public int Count => (tail - head) & mask; public T this[int i] => data[(head + i) & mask]; public T First => data[head]; public T Last => data[(tail - 1) & mask]; public T PopFirst() { if (head == tail) throw new InvalidOperationException(""deque is empty""); var item = data[head]; head = (head + 1) & mask; return item; } public T PopLast() { if (head == tail) throw new InvalidOperationException(""deque is empty""); return data[tail = (tail - 1) & mask]; } public void AddFirst(T item) { data[head = (head - 1) & mask] = item; if (head == tail) Expand(); } public void AddLast(T item) { data[tail] = item; tail = (tail + 1) & mask; if (head == tail) Expand(); } void Expand() { var oldSize = data.Length; var newArray = new T[oldSize << 1]; var hsize = oldSize - head; Array.Copy(data, head, newArray, 0, hsize); Array.Copy(data, 0, newArray, hsize, tail); data = newArray; mask = data.Length - 1; head = 0; tail = oldSize; } public void Add(T item) => AddLast(item); bool ICollection<T>.IsReadOnly => false; void ICollection<T>.Clear() => head = tail = 0; bool ICollection<T>.Contains(T item) { if (head == tail) return false; if (head < tail) { var ix = Array.IndexOf(data, item); return ix >= 0 && ix < tail; } else { var ix = Array.IndexOf(data, item, head); if (ix >= 0) return true; ix = Array.IndexOf(data, item); return ix >= 0 && ix < tail; } } void ICollection<T>.CopyTo(T[] array, int arrayIndex) { if (head <= tail) { Array.Copy(data, head, array, arrayIndex, tail - head); } else { var hsize = data.Length - head; Array.Copy(data, head, array, arrayIndex, hsize); Array.Copy(data, 0, array, arrayIndex + hsize, tail); } } public IEnumerable<T> Reversed() { Enumerator e = new Enumerator(this, true); while (e.MoveNext()) yield return e.Current; } public bool Remove(T item) { throw new NotSupportedException(); } public Enumerator GetEnumerator() => new Enumerator(this, false); IEnumerator<T> IEnumerable<T>.GetEnumerator() => GetEnumerator(); IEnumerator IEnumerable.GetEnumerator() => GetEnumerator(); public struct Enumerator : IEnumerator<T>, IEnumerator { readonly Deque<T> deque; readonly bool isReverse; int index; public readonly int last; public T Current => deque.data[index]; public Enumerator(Deque<T> deque, bool isReverse) { this.deque = deque; this.isReverse = isReverse; if (isReverse) { index = deque.tail + 1; last = deque.head; } else { index = deque.head - 1; last = (deque.tail - 1) & deque.mask; } } object IEnumerator.Current => Current; public bool MoveNext() { if (index == last) return false; if (isReverse) --index; else ++index; index &= deque.mask; return true; } public void Reset() { throw new NotSupportedException(); } public void Dispose() { } } } } "),
new AclFileInfo(@"Stl/BinarySearchExtension.cs", new string[] { @"AtCoder.Stl.BinarySearchExtension" }, new string[] { @"using System;", @"using System.Collections.Generic;" }, new string[] {  }, @"namespace AtCoder.Stl { public static class BinarySearchExtension { public static int BinarySearch(int ok, int ng, Predicate<int> Ok) { while (System.Math.Abs(ok - ng) > 1) { var m = (ok + ng) >> 1; if (Ok(m)) ok = m; else ng = m; } return ok; } public static int LowerBound<T>(this T[] a, T v, IComparer<T> cmp) => BinarySearch(a.AsSpan(), v, cmp, true); public static int LowerBound<T>(this T[] a, T v) => BinarySearch(a.AsSpan(), v, Comparer<T>.Default, true); public static int UpperBound<T>(this T[] a, T v, IComparer<T> cmp) => BinarySearch(a.AsSpan(), v, cmp, false); public static int UpperBound<T>(this T[] a, T v) => BinarySearch(a.AsSpan(), v, Comparer<T>.Default, false); public static int LowerBound<T>(this IList<T> a, T v, IComparer<T> cmp) => BinarySearch(a, v, cmp, true); public static int LowerBound<T>(this IList<T> a, T v) => BinarySearch(a, v, Comparer<T>.Default, true); public static int UpperBound<T>(this IList<T> a, T v, IComparer<T> cmp) => BinarySearch(a, v, cmp, false); public static int UpperBound<T>(this IList<T> a, T v) => BinarySearch(a, v, Comparer<T>.Default, false); public static int LowerBound<T>(this Span<T> a, T v, IComparer<T> cmp) => BinarySearch(a, v, cmp, true); public static int LowerBound<T>(this Span<T> a, T v) => BinarySearch(a, v, Comparer<T>.Default, true); public static int UpperBound<T>(this Span<T> a, T v, IComparer<T> cmp) => BinarySearch(a, v, cmp, false); public static int UpperBound<T>(this Span<T> a, T v) => BinarySearch(a, v, Comparer<T>.Default, false); public static int LowerBound<T>(this ReadOnlySpan<T> a, T v, IComparer<T> cmp) => BinarySearch(a, v, cmp, true); public static int LowerBound<T>(this ReadOnlySpan<T> a, T v) => BinarySearch(a, v, Comparer<T>.Default, true); public static int UpperBound<T>(this ReadOnlySpan<T> a, T v, IComparer<T> cmp) => BinarySearch(a, v, cmp, false); public static int UpperBound<T>(this ReadOnlySpan<T> a, T v) => BinarySearch(a, v, Comparer<T>.Default, false); static int BinarySearch<T>(this IList<T> a, T v, IComparer<T> cmp, bool isLowerBound) { int ok = a.Count; int ng = -1; while (ok - ng > 1) { var m = (ok + ng) >> 1; var c = cmp.Compare(a[m], v); if (c > 0 || (c == 0 && isLowerBound)) ok = m; else ng = m; } return ok; } static int BinarySearch<T>(this ReadOnlySpan<T> a, T v, IComparer<T> cmp, bool isLowerBound) { int ok = a.Length; int ng = -1; while (ok - ng > 1) { var m = (ok + ng) >> 1; var c = cmp.Compare(a[m], v); if (c > 0 || (c == 0 && isLowerBound)) ok = m; else ng = m; } return ok; } } } "),
new AclFileInfo(@"Stl/SetDictionary.cs", new string[] { @"AtCoder.Stl.SetDictionary<TKey, TValue>", @"AtCoder.Stl.SetDictionary<TKey, TValue>.Enumerator", @"AtCoder.Stl.SetDictionary<TKey, TValue>.Node" }, new string[] { @"using System;", @"using System.Collections;", @"using System.Collections.Generic;", @"using System.Diagnostics;", @"using System.Linq;", @"using System.Numerics;", @"using System.Runtime.CompilerServices;", @"using AtCoder.Util.Internal;" }, new string[] { @"Util/Internal/CollectionDebugView.cs" }, @"namespace AtCoder.Stl { [DebuggerTypeProxy(typeof(CollectionDebugView<>))] [DebuggerDisplay(""Count = {"" + nameof(Count) + ""}"")] public class SetDictionary<TKey, TValue> : IDictionary<TKey, TValue>, IReadOnlyDictionary<TKey, TValue> { internal const string LISENCE = @""
Original is SortedSet<T>

Copyright (c) .NET Foundation and Contributors
Released under the MIT license
https://github.com/dotnet/runtime/blob/master/LICENSE.TXT
""; public bool IsMulti { get; } public KeyValuePair<TKey, TValue> Min { get { if (root == null) return default; var cur = root; while (cur.Left != null) { cur = cur.Left; } return cur.Pair; } } public KeyValuePair<TKey, TValue> Max { get { if (root == null) return default; var cur = root; while (cur.Right != null) { cur = cur.Right; } return cur.Pair; } } public Node FindNode(TKey key) { Node current = root; while (current != null) { int order = comparer.Compare(key, current.Key); if (order == 0) return current; current = order < 0 ? current.Left : current.Right; } return null; } public int Index(Node node) { var ret = NodeSize(node.Left); Node prev = node; node = node.Parent; while (prev != root) { if (node.Left != prev) { ret += NodeSize(node.Left) + 1; } prev = node; node = node.Parent; } return ret; } public Node FindByIndex(int index) { var current = root; var currentIndex = current.Size - NodeSize(current.Right) - 1; while (currentIndex != index) { if (currentIndex > index) { current = current.Left; if (current == null) break; currentIndex -= NodeSize(current.Right) + 1; } else { current = current.Right; if (current == null) break; currentIndex += NodeSize(current.Left) + 1; } } return current; } public (Node node, int index) BinarySearch(TKey key, bool isLowerBound) { Node right = null; Node current = root; if (current == null) return (null, -1); int ri = -1; int ci = NodeSize(current.Left); while (true) { var order = comparer.Compare(key, current.Key); if (order < 0 || (isLowerBound && order == 0)) { right = current; ri = ci; current = current.Left; if (current != null) ci -= NodeSize(current.Right) + 1; else break; } else { current = current.Right; if (current != null) ci += NodeSize(current.Left) + 1; else break; } } return (right, ri); } public Node FindNodeLowerBound(TKey key) => BinarySearch(key, true).node; public Node FindNodeUpperBound(TKey key) => BinarySearch(key, false).node; public KeyValuePair<TKey, TValue> LowerBoundItem(TKey key) => BinarySearch(key, true).node.Pair; public KeyValuePair<TKey, TValue> UpperBoundItem(TKey key) => BinarySearch(key, false).node.Pair; public int LowerBoundIndex(TKey key) => BinarySearch(key, true).index; public int UpperBoundIndex(TKey key) => BinarySearch(key, false).index; public IEnumerable<KeyValuePair<TKey, TValue>> Reversed() { var e = new Enumerator(this, true, null); while (e.MoveNext()) yield return e.Current; } public IEnumerable<KeyValuePair<TKey, TValue>> Enumerate(Node from) => Enumerate(from, false); public IEnumerable<KeyValuePair<TKey, TValue>> Enumerate(Node from, bool reverse) { if (from == null) yield break; var e = new Enumerator(this, reverse, from); while (e.MoveNext()) yield return e.Current; } public SetDictionary(bool isMulti = false) : this(Comparer<TKey>.Default, isMulti) { } public SetDictionary(IDictionary<TKey, TValue> dict, bool isMulti = false) : this(dict, Comparer<TKey>.Default, isMulti) { } public SetDictionary(IComparer<TKey> comparer, bool isMulti = false) { this.comparer = comparer; IsMulti = isMulti; } public SetDictionary(IDictionary<TKey, TValue> dict, IComparer<TKey> comparer, bool isMulti = false) { this.comparer = comparer; var arr = InitArray(dict); root = ConstructRootFromSortedArray(arr, 0, arr.Length - 1, null); IsMulti = isMulti; } protected KeyValuePair<TKey, TValue>[] InitArray(IEnumerable<KeyValuePair<TKey, TValue>> collection) { var comparer = Comparer<KeyValuePair<TKey, TValue>>.Create((a, b) => this.comparer.Compare(a.Key, b.Key)); KeyValuePair<TKey, TValue>[] arr; if (IsMulti) { arr = collection.ToArray(); Array.Sort(arr, comparer); } else { var list = new List<KeyValuePair<TKey, TValue>>(collection); list.Sort(comparer); for (int i = list.Count - 1; i > 0; i--) if (this.comparer.Compare(list[i - 1].Key, list[i].Key) == 0) list.RemoveAt(i); arr = list.ToArray(); } return arr; } public int Count => NodeSize(root); protected static int NodeSize(Node node) => node == null ? 0 : node.Size; protected readonly IComparer<TKey> comparer; bool ICollection<KeyValuePair<TKey, TValue>>.IsReadOnly => false; ICollection<TKey> IDictionary<TKey, TValue>.Keys => throw new NotSupportedException(); ICollection<TValue> IDictionary<TKey, TValue>.Values => throw new NotSupportedException(); IEnumerable<TKey> IReadOnlyDictionary<TKey, TValue>.Keys => throw new NotSupportedException(); IEnumerable<TValue> IReadOnlyDictionary<TKey, TValue>.Values => throw new NotSupportedException(); public TValue this[TKey key] { get => throw new NotSupportedException(); set => throw new NotSupportedException(); } Node root; static Node ConstructRootFromSortedArray(KeyValuePair<TKey, TValue>[] arr, int startIndex, int endIndex, Node redNode) { int size = endIndex - startIndex + 1; Node root; switch (size) { case 0: return null; case 1: root = new Node(arr[startIndex], false); if (redNode != null) { root.Left = redNode; } break; case 2: root = new Node(arr[startIndex], false) { Right = new Node(arr[endIndex], true) }; if (redNode != null) { root.Left = redNode; } break; case 3: root = new Node(arr[startIndex + 1], false) { Left = new Node(arr[startIndex], false), Right = new Node(arr[endIndex], false) }; if (redNode != null) { root.Left.Left = redNode; } break; default: int midpt = ((startIndex + endIndex) / 2); root = new Node(arr[midpt], false) { Left = ConstructRootFromSortedArray(arr, startIndex, midpt - 1, redNode), Right = size % 2 == 0 ? ConstructRootFromSortedArray(arr, midpt + 2, endIndex, new Node(arr[midpt + 1], true)) : ConstructRootFromSortedArray(arr, midpt + 1, endIndex, null) }; break; } return root; } void IDictionary<TKey, TValue>.Add(TKey key, TValue value) => Add(key, value); void ICollection<KeyValuePair<TKey, TValue>>.Add(KeyValuePair<TKey, TValue> pair) => Add(pair.Key, pair.Value); public bool Add(TKey key, TValue value) { if (root == null) { root = new Node(key, value, false); return true; } Node current = root; Node parent = null; Node grandParent = null; Node greatGrandParent = null; int order = 0; while (current != null) { order = comparer.Compare(key, current.Key); if (order == 0 && !IsMulti) { current.Key = key; root.IsRed = false; return false; } if (Is4Node(current)) { Split4Node(current); if (IsNonNullRed(parent) == true) { InsertionBalance(current, ref parent, grandParent, greatGrandParent); } } greatGrandParent = grandParent; grandParent = parent; parent = current; current = (order < 0) ? current.Left : current.Right; } Node node = new Node(key, value, true); if (order >= 0) parent.Right = node; else parent.Left = node; if (parent.IsRed) InsertionBalance(node, ref parent, grandParent, greatGrandParent); root.IsRed = false; return true; } public bool Remove(TKey key) { if (root == null) return false; Node current = root; Node parent = null; Node grandParent = null; Node match = null; Node parentOfMatch = null; bool foundMatch = false; while (current != null) { if (Is2Node(current)) { if (parent == null) { current.IsRed = true; } else { Node sibling = GetSibling(current, parent); if (sibling.IsRed) { if (parent.Right == sibling) RotateLeft(parent); else RotateRight(parent); parent.IsRed = true; sibling.IsRed = false; ReplaceChildOrRoot(grandParent, parent, sibling); grandParent = sibling; if (parent == match) parentOfMatch = sibling; sibling = (parent.Left == current) ? parent.Right : parent.Left; } if (Is2Node(sibling)) { Merge2Nodes(parent); } else { TreeRotation rotation = GetRotation(parent, current, sibling); Node newGrandParent = Rotate(parent, rotation); newGrandParent.IsRed = parent.IsRed; parent.IsRed = false; current.IsRed = true; ReplaceChildOrRoot(grandParent, parent, newGrandParent); if (parent == match) { parentOfMatch = newGrandParent; } } } } int order = foundMatch ? -1 : comparer.Compare(key, current.Key); if (order == 0) { foundMatch = true; match = current; parentOfMatch = parent; } grandParent = parent; parent = current; current = order < 0 ? current.Left : current.Right; } if (match != null) { ReplaceNode(match, parentOfMatch, parent, grandParent); } if (root != null) { root.IsRed = false; } return foundMatch; } bool ICollection<KeyValuePair<TKey, TValue>>.Remove(KeyValuePair<TKey, TValue> pair) { if (root == null) return false; Node current = root; Node parent = null; Node grandParent = null; Node match = null; Node parentOfMatch = null; bool foundMatch = false; while (current != null) { if (Is2Node(current)) { if (parent == null) { current.IsRed = true; } else { Node sibling = GetSibling(current, parent); if (sibling.IsRed) { if (parent.Right == sibling) RotateLeft(parent); else RotateRight(parent); parent.IsRed = true; sibling.IsRed = false; ReplaceChildOrRoot(grandParent, parent, sibling); grandParent = sibling; if (parent == match) parentOfMatch = sibling; sibling = (parent.Left == current) ? parent.Right : parent.Left; } if (Is2Node(sibling)) { Merge2Nodes(parent); } else { TreeRotation rotation = GetRotation(parent, current, sibling); Node newGrandParent = Rotate(parent, rotation); newGrandParent.IsRed = parent.IsRed; parent.IsRed = false; current.IsRed = true; ReplaceChildOrRoot(grandParent, parent, newGrandParent); if (parent == match) { parentOfMatch = newGrandParent; } } } } int order = foundMatch ? -1 : comparer.Compare(pair.Key, current.Key); if (order == 0 && EqualityComparer<TValue>.Default.Equals(pair.Value, current.Value)) { foundMatch = true; match = current; parentOfMatch = parent; } grandParent = parent; parent = current; current = order < 0 ? current.Left : current.Right; } if (match != null) { ReplaceNode(match, parentOfMatch, parent, grandParent); } if (root != null) { root.IsRed = false; } return foundMatch; } public void Clear() { root = null; } public bool ContainsKey(TKey key) => FindNode(key) != null; bool ICollection<KeyValuePair<TKey, TValue>>.Contains(KeyValuePair<TKey, TValue> pair) { var node = FindNodeLowerBound(pair.Key); if (node == null) return false; var e = new Enumerator(this, false, node); while (e.MoveNext()) { if (comparer.Compare(pair.Key, e.Current.Key) != 0) break; if (EqualityComparer<TValue>.Default.Equals(pair.Value, e.Current.Value)) return true; } return false; } public void CopyTo(KeyValuePair<TKey, TValue>[] array, int arrayIndex) { foreach (var item in this) array[arrayIndex++] = item; } public bool TryGetValue(TKey key, out TValue value) { var node = FindNode(key); if (node == null) { value = default; return false; } value = node.Value; return true; } public Enumerator GetEnumerator() => new Enumerator(this); IEnumerator<KeyValuePair<TKey, TValue>> IEnumerable<KeyValuePair<TKey, TValue>>.GetEnumerator() => new Enumerator(this); IEnumerator IEnumerable.GetEnumerator() => new Enumerator(this); static bool Is2Node(Node node) => IsNonNullBlack(node) && IsNullOrBlack(node.Left) && IsNullOrBlack(node.Right); static bool Is4Node(Node node) => IsNonNullRed(node.Left) && IsNonNullRed(node.Right); static bool IsNonNullRed(Node node) => node != null && node.IsRed; static bool IsNonNullBlack(Node node) => node != null && !node.IsRed; static bool IsNullOrBlack(Node node) => node == null || !node.IsRed; void ReplaceNode(Node match, Node parentOfMatch, Node succesor, Node parentOfSuccesor) { if (succesor == match) { succesor = match.Left; } else { if (succesor.Right != null) { succesor.Right.IsRed = false; } if (parentOfSuccesor != match) { parentOfSuccesor.Left = succesor.Right; succesor.Right = match.Right; } succesor.Left = match.Left; } if (succesor != null) { succesor.IsRed = match.IsRed; } ReplaceChildOrRoot(parentOfMatch, match, succesor); } static void Merge2Nodes(Node parent) { parent.IsRed = false; parent.Left.IsRed = true; parent.Right.IsRed = true; } static void Split4Node(Node node) { node.IsRed = true; node.Left.IsRed = false; node.Right.IsRed = false; } static Node GetSibling(Node node, Node parent) { return parent.Left == node ? parent.Right : parent.Left; } void InsertionBalance(Node current, ref Node parent, Node grandParent, Node greatGrandParent) { bool parentIsOnRight = grandParent.Right == parent; bool currentIsOnRight = parent.Right == current; Node newChildOfGreatGrandParent; if (parentIsOnRight == currentIsOnRight) { newChildOfGreatGrandParent = currentIsOnRight ? RotateLeft(grandParent) : RotateRight(grandParent); } else { newChildOfGreatGrandParent = currentIsOnRight ? RotateLeftRight(grandParent) : RotateRightLeft(grandParent); parent = greatGrandParent; } grandParent.IsRed = true; newChildOfGreatGrandParent.IsRed = false; ReplaceChildOrRoot(greatGrandParent, grandParent, newChildOfGreatGrandParent); } static Node Rotate(Node node, TreeRotation rotation) { switch (rotation) { case TreeRotation.Right: node.Left.Left.IsRed = false; return RotateRight(node); case TreeRotation.Left: node.Right.Right.IsRed = false; return RotateLeft(node); case TreeRotation.RightLeft: return RotateRightLeft(node); case TreeRotation.LeftRight: return RotateLeftRight(node); default: throw new InvalidOperationException(); } } static Node RotateLeft(Node node) { Node child = node.Right; node.Right = child.Left; child.Left = node; return child; } static Node RotateLeftRight(Node node) { Node child = node.Left; Node grandChild = child.Right; node.Left = grandChild.Right; grandChild.Right = node; child.Right = grandChild.Left; grandChild.Left = child; return grandChild; } static Node RotateRight(Node node) { Node child = node.Left; node.Left = child.Right; child.Right = node; return child; } static Node RotateRightLeft(Node node) { Node child = node.Right; Node grandChild = child.Left; node.Right = grandChild.Left; grandChild.Left = node; child.Left = grandChild.Right; grandChild.Right = child; return grandChild; } void ReplaceChildOrRoot(Node parent, Node child, Node newChild) { if (parent != null) { if (parent.Left == child) { parent.Left = newChild; } else { parent.Right = newChild; } } else { root = newChild; } } static TreeRotation GetRotation(Node parent, Node current, Node sibling) { if (IsNonNullRed(sibling.Left)) { if (parent.Left == current) { return TreeRotation.RightLeft; } return TreeRotation.Right; } else { if (parent.Left == current) { return TreeRotation.Left; } return TreeRotation.LeftRight; } } public struct Enumerator : IEnumerator<KeyValuePair<TKey, TValue>> { SetDictionary<TKey, TValue> tree; Stack<Node> stack; Node current; bool reverse; internal Enumerator(SetDictionary<TKey, TValue> set) : this(set, false, null) { } internal Enumerator(SetDictionary<TKey, TValue> set, bool reverse, Node startNode) { tree = set; stack = new Stack<Node>(2 * Log2(tree.Count + 1)); current = null; this.reverse = reverse; if (startNode == null) IntializeAll(); else Intialize(startNode); } void IntializeAll() { var node = tree.root; while (node != null) { var next = reverse ? node.Right : node.Left; stack.Push(node); node = next; } } void Intialize(Node startNode) { if (startNode == null) throw new InvalidOperationException(nameof(startNode) + ""is null""); current = null; var node = startNode; var list = new List<Node>(Log2(tree.Count + 1)); var comparer = tree.comparer; if (reverse) { while (node != null) { list.Add(node); var parent = node.Parent; if (parent == null || parent.Left == node) { node = parent; break; } node = parent; } while (node != null) { var parent = node.Parent; if (parent == null || parent.Right == node) { node = parent; break; } node = parent; } while (node != null) { if (comparer.Compare(startNode.Key, node.Key) >= 0) list.Add(node); node = node.Parent; } } else { while (node != null) { list.Add(node); var parent = node.Parent; if (parent == null || parent.Right == node) { node = parent; break; } node = parent; } while (node != null) { var parent = node.Parent; if (parent == null || parent.Left == node) { node = parent; break; } node = parent; } while (node != null) { if (comparer.Compare(startNode.Key, node.Key) <= 0) list.Add(node); node = node.Parent; } } list.Reverse(); foreach (var n in list) stack.Push(n); } [MethodImpl(MethodImplOptions.AggressiveInlining)] static int Log2(int num) => BitOperations.Log2((uint)num) + 1; public KeyValuePair<TKey, TValue> Current => current == null ? default : current.Pair; public bool MoveNext() { if (stack.Count == 0) { current = null; return false; } current = stack.Pop(); var node = reverse ? current.Left : current.Right; while (node != null) { var next = reverse ? node.Right : node.Left; stack.Push(node); node = next; } return true; } object IEnumerator.Current => Current; public void Dispose() { } public void Reset() => throw new NotSupportedException(); } public class Node { public bool IsRed; public TKey Key; public TValue Value; public KeyValuePair<TKey, TValue> Pair => KeyValuePair.Create(Key, Value); public Node Parent { get; private set; } Node _left; public Node Left { get { return _left; } set { _left = value; if (value != null) value.Parent = this; for (var cur = this; cur != null; cur = cur.Parent) { if (!cur.UpdateSize()) break; if (cur.Parent != null && cur.Parent.Left != cur && cur.Parent.Right != cur) { cur.Parent = null; break; } } } } Node _right; public Node Right { get { return _right; } set { _right = value; if (value != null) value.Parent = this; for (var cur = this; cur != null; cur = cur.Parent) { if (!cur.UpdateSize()) break; if (cur.Parent != null && cur.Parent.Left != cur && cur.Parent.Right != cur) { cur.Parent = null; break; } } } } public int Size { get; private set; } = 1; public Node(KeyValuePair<TKey, TValue> pair, bool isRed) { Key = pair.Key; Value = pair.Value; IsRed = isRed; } public Node(TKey key, TValue value, bool isRed) { Key = key; Value = value; IsRed = isRed; } public bool UpdateSize() { var oldsize = Size; var size = 1; if (Left != null) size += Left.Size; if (Right != null) size += Right.Size; Size = size; return oldsize != size; } public override string ToString() => $""Size = {Size}, Item = {Key}""; } enum TreeRotation : byte { Left = 1, Right = 2, RightLeft = 3, LeftRight = 4, } } } "),
new AclFileInfo(@"Graph/MaxFlow.cs", new string[] { @"AtCoder.MFGraphInt", @"AtCoder.MFGraphLong", @"AtCoder.MFGraph<TValue, TOp>", @"AtCoder.MFGraph<TValue, TOp>.Edge", @"AtCoder.MFGraph<TValue, TOp>.EdgeInternal" }, new string[] { @"using System.Collections.Generic;", @"using System.Diagnostics;" }, new string[] { @"Algebra/Operators.cs" }, @"namespace AtCoder { public class MFGraphInt : MFGraph<int, IntOperator> { public MFGraphInt(int n) : base(n) { } } public class MFGraphLong : MFGraph<long, LongOperator> { public MFGraphLong(int n) : base(n) { } } public class MFGraph<TValue, TOp> where TOp : ISignedNumOperator<TValue> { static readonly TOp op = default; public MFGraph(int n) { _n = n; _g = new List<EdgeInternal>[n]; for (int i = 0; i < n; i++) { _g[i] = new List<EdgeInternal>(); } _pos = new List<(int first, int second)>(); } public int AddEdge(int from, int to, TValue cap) { int m = _pos.Count; Debug.Assert(0 <= from && from < _n); Debug.Assert(0 <= to && to < _n); Debug.Assert(op.LessThanOrEqual(default, cap)); _pos.Add((from, _g[from].Count)); _g[from].Add(new EdgeInternal(to, _g[to].Count, cap)); _g[to].Add(new EdgeInternal(from, _g[from].Count - 1, default)); return m; } public Edge GetEdge(int i) { int m = _pos.Count; Debug.Assert(0 <= i && i < m); var _e = _g[_pos[i].first][_pos[i].second]; var _re = _g[_e.To][_e.Rev]; return new Edge(_pos[i].first, _e.To, op.Add(_e.Cap, _re.Cap), _re.Cap); } public List<Edge> Edges() { int m = _pos.Count; var result = new List<Edge>(); for (int i = 0; i < m; i++) { result.Add(GetEdge(i)); } return result; } public void ChangeEdge(int i, TValue newCap, TValue newFlow) { int m = _pos.Count; Debug.Assert(0 <= i && i < m); Debug.Assert(op.LessThanOrEqual(default, newFlow) && op.LessThanOrEqual(newFlow, newCap)); var _e = _g[_pos[i].first][_pos[i].second]; var _re = _g[_e.To][_e.Rev]; _e.Cap = op.Subtract(newCap, newFlow); _re.Cap = newFlow; } public TValue Flow(int s, int t) { return Flow(s, t, op.MaxValue); } public TValue Flow(int s, int t, TValue flowLimit) { Debug.Assert(0 <= s && s < _n); Debug.Assert(0 <= t && t < _n); var level = new int[_n]; var iter = new int[_n]; var que = new Queue<int>(); void Bfs() { for (int i = 0; i < _n; i++) { level[i] = -1; } level[s] = 0; que.Clear(); que.Enqueue(s); while (que.Count > 0) { int v = que.Dequeue(); foreach (var e in _g[v]) { if (op.Equals(e.Cap, default) || level[e.To] >= 0) continue; level[e.To] = level[v] + 1; if (e.To == t) return; que.Enqueue(e.To); } } } TValue Dfs(int v, TValue up) { if (v == s) return up; var res = default(TValue); int level_v = level[v]; for (; iter[v] < _g[v].Count; iter[v]++) { EdgeInternal e = _g[v][iter[v]]; if (level_v <= level[e.To] || op.Equals(_g[e.To][e.Rev].Cap, default)) continue; var up1 = op.Subtract(up, res); var up2 = _g[e.To][e.Rev].Cap; var d = Dfs(e.To, op.LessThan(up1, up2) ? up1 : up2); if (op.Compare(d, default) <= 0) continue; _g[v][iter[v]].Cap = op.Add(_g[v][iter[v]].Cap, d); _g[e.To][e.Rev].Cap = op.Subtract(_g[e.To][e.Rev].Cap, d); res = op.Add(res, d); if (res.Equals(up)) break; } return res; } TValue flow = default; while (op.LessThan(flow, flowLimit)) { Bfs(); if (level[t] == -1) break; for (int i = 0; i < _n; i++) { iter[i] = 0; } while (op.LessThan(flow, flowLimit)) { var f = Dfs(t, op.Subtract(flowLimit, flow)); if (op.Equals(f, default)) break; flow = op.Add(flow, f); } } return flow; } public bool[] MinCut(int s) { var visited = new bool[_n]; var que = new Queue<int>(); que.Enqueue(s); while (que.Count > 0) { int p = que.Dequeue(); visited[p] = true; foreach (var e in _g[p]) { if (!op.Equals(e.Cap, default) && !visited[e.To]) { visited[e.To] = true; que.Enqueue(e.To); } } } return visited; } public struct Edge { public int From { get; set; } public int To { get; set; } public TValue Cap { get; set; } public TValue Flow { get; set; } public Edge(int from, int to, TValue cap, TValue flow) { From = from; To = to; Cap = cap; Flow = flow; } }; private class EdgeInternal { public int To { get; set; } public int Rev { get; set; } public TValue Cap { get; set; } public EdgeInternal(int to, int rev, TValue cap) { To = to; Rev = rev; Cap = cap; } }; private readonly int _n; private readonly List<(int first, int second)> _pos; private readonly List<EdgeInternal>[] _g; } } "),
new AclFileInfo(@"Graph/TwoSat.cs", new string[] { @"AtCoder.TwoSat" }, new string[] { @"using System.Diagnostics;" }, new string[] { @"Graph/SCCGraph.cs" }, @"namespace AtCoder { [DebuggerDisplay(""Count = {_n}"")] public class TwoSat { readonly int _n; readonly private bool[] _answer; readonly private SCCGraph scc; public TwoSat(int n) { Debug.Assert(unchecked((uint)n <= 100_000_000)); _n = n; _answer = new bool[n]; scc = new SCCGraph(2 * n); } public void AddClause(int i, bool f, int j, bool g) { Debug.Assert(unchecked((uint)i < _n)); Debug.Assert(unchecked((uint)j < _n)); scc.AddEdge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0)); scc.AddEdge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0)); } public bool Satisfiable() { var sccs = scc.SCC(); var id = new int[2 * _n]; for (int i = 0; i < sccs.Count; i++) { foreach (var v in sccs[i]) { id[v] = i; } } for (int i = 0; i < _n; i++) { if (id[2 * i] == id[2 * i + 1]) { return false; } else { _answer[i] = id[2 * i] < id[2 * i + 1]; } } return true; } public bool[] Answer() => _answer; } } "),
new AclFileInfo(@"Graph/MinCostFlow.cs", new string[] { @"AtCoder.ICastOperator<TFrom, TTo>", @"AtCoder.SameTypeCastOperator<T>", @"AtCoder.IntToLongCastOperator", @"AtCoder.McfGraphInt", @"AtCoder.McfGraphLong", @"AtCoder.McfGraph<TCap, TCapOp, TCost, TCostOp, TCast>", @"AtCoder.McfGraph<TCap, TCapOp, TCost, TCostOp, TCast>.Edge", @"AtCoder.McfGraph<TCap, TCapOp, TCost, TCostOp, TCast>.EdgeInternal", @"AtCoder.McfGraph<TCap, TCapOp, TCost, TCostOp, TCast>.PriorityQueueForMcf" }, new string[] { @"using System;", @"using System.Collections.Generic;", @"using System.Diagnostics;", @"using System.Linq;", @"using System.Runtime.CompilerServices;" }, new string[] { @"Algebra/Operators.cs" }, @"namespace AtCoder { public interface ICastOperator<TFrom, TTo> where TFrom : struct where TTo : struct { TTo Cast(TFrom y); } public struct SameTypeCastOperator<T> : ICastOperator<T, T> where T : struct { public T Cast(T y) => y; } public struct IntToLongCastOperator : ICastOperator<int, long> { public long Cast(int y) => y; } public class McfGraphInt : McfGraph<int, IntOperator, int, IntOperator, SameTypeCastOperator<int>> { public McfGraphInt(int n) : base(n) { } } public class McfGraphLong : McfGraph<long, LongOperator, long, LongOperator, SameTypeCastOperator<long>> { public McfGraphLong(int n) : base(n) { } } public class McfGraph<TCap, TCapOp, TCost, TCostOp, TCast> where TCap : struct where TCapOp : struct, ISignedNumOperator<TCap> where TCost : struct where TCostOp : struct, ISignedNumOperator<TCost> where TCast : ICastOperator<TCap, TCost> { static readonly TCapOp capOp = default; static readonly TCostOp costOp = default; static readonly TCast cast = default; public McfGraph(int n) { _n = n; _g = new List<EdgeInternal>[n]; for (int i = 0; i < n; i++) { _g[i] = new List<EdgeInternal>(); } _pos = new List<(int first, int second)>(); } public int AddEdge(int from, int to, TCap cap, TCost cost) { Debug.Assert(0 <= from && from < _n); Debug.Assert(0 <= to && to < _n); int m = _pos.Count; _pos.Add((from, _g[from].Count)); _g[from].Add(new EdgeInternal(to, _g[to].Count, cap, cost)); _g[to].Add(new EdgeInternal(from, _g[from].Count - 1, default, costOp.Negate(cost))); return m; } public Edge GetEdge(int i) { int m = _pos.Count; Debug.Assert(0 <= i && i < m); var _e = _g[_pos[i].first][_pos[i].second]; var _re = _g[_e.To][_e.Rev]; return new Edge(_pos[i].first, _e.To, capOp.Add(_e.Cap, _re.Cap), _re.Cap, _e.Cost); } public List<Edge> Edges() { int m = _pos.Count; var result = new List<Edge>(); for (int i = 0; i < m; i++) { result.Add(GetEdge(i)); } return result; } public (TCap cap, TCost cost) Flow(int s, int t) { return Flow(s, t, capOp.MaxValue); } public (TCap cap, TCost cost) Flow(int s, int t, TCap flowLimit) { return Slope(s, t, flowLimit).Last(); } public List<(TCap cap, TCost cost)> Slope(int s, int t) { return Slope(s, t, capOp.MaxValue); } public List<(TCap cap, TCost cost)> Slope(int s, int t, TCap flowLimit) { Debug.Assert(0 <= s && s < _n); Debug.Assert(0 <= t && t < _n); Debug.Assert(s != t); var dual = new TCost[_n]; var dist = new TCost[_n]; var pv = new int[_n]; var pe = new int[_n]; var vis = new bool[_n]; bool DualRef() { dist.AsSpan().Fill(costOp.MaxValue); pv.AsSpan().Fill(-1); pe.AsSpan().Fill(-1); vis.AsSpan().Fill(false); var que = new PriorityQueueForMcf(); dist[s] = default; que.Enqueue(default, s); while (que.Count > 0) { int v = que.Dequeue().to; if (vis[v]) continue; vis[v] = true; if (v == t) break; for (int i = 0; i < _g[v].Count; i++) { var e = _g[v][i]; if (vis[e.To] || capOp.Equals(e.Cap, default)) continue; TCost cost = costOp.Add(costOp.Subtract(e.Cost, dual[e.To]), dual[v]); if (costOp.GreaterThan(costOp.Subtract(dist[e.To], dist[v]), cost)) { dist[e.To] = costOp.Add(dist[v], cost); pv[e.To] = v; pe[e.To] = i; que.Enqueue(dist[e.To], e.To); } } } if (!vis[t]) { return false; } for (int v = 0; v < _n; v++) { if (!vis[v]) continue; dual[v] = costOp.Subtract(dual[v], costOp.Subtract(dist[t], dist[v])); } return true; } TCap flow = default; TCost cost = default; TCost prev_cost = costOp.Decrement(default); var result = new List<(TCap cap, TCost cost)>(); result.Add((flow, cost)); while (capOp.LessThan(flow, flowLimit)) { if (!DualRef()) break; TCap c = capOp.Subtract(flowLimit, flow); for (int v = t; v != s; v = pv[v]) { if (capOp.LessThan(_g[pv[v]][pe[v]].Cap, c)) { c = _g[pv[v]][pe[v]].Cap; } } for (int v = t; v != s; v = pv[v]) { _g[pv[v]][pe[v]].Cap = capOp.Subtract(_g[pv[v]][pe[v]].Cap, c); _g[v][_g[pv[v]][pe[v]].Rev].Cap = capOp.Add(_g[v][_g[pv[v]][pe[v]].Rev].Cap, c); } TCost d = costOp.Negate(dual[s]); flow = capOp.Add(flow, c); cost = costOp.Add(cost, costOp.Multiply(cast.Cast(c), d)); if (costOp.Equals(prev_cost, d)) { result.RemoveAt(result.Count - 1); } result.Add((flow, cost)); prev_cost = cost; } return result; } public struct Edge { public int From { get; set; } public int To { get; set; } public TCap Cap { get; set; } public TCap Flow { get; set; } public TCost Cost { get; set; } public Edge(int from, int to, TCap cap, TCap flow, TCost cost) { From = from; To = to; Cap = cap; Flow = flow; Cost = cost; } }; private class EdgeInternal { public int To { get; set; } public int Rev { get; set; } public TCap Cap { get; set; } public TCost Cost { get; set; } public EdgeInternal(int to, int rev, TCap cap, TCost cost) { To = to; Rev = rev; Cap = cap; Cost = cost; } }; private readonly int _n; private readonly List<(int first, int second)> _pos; private readonly List<EdgeInternal>[] _g; private class PriorityQueueForMcf { private (TCost cost, int to)[] _heap; public int Count { get; private set; } = 0; public PriorityQueueForMcf() { _heap = new (TCost cost, int to)[1024]; } public void Enqueue(TCost cost, int to) { var pair = (cost, to); if (_heap.Length == Count) { var newHeap = new (TCost cost, int to)[_heap.Length * 2]; _heap.CopyTo(newHeap, 0); _heap = newHeap; } _heap[Count] = pair; ++Count; int c = Count - 1; while (c > 0) { int p = (c - 1) >> 1; if (Compare(_heap[p].cost, cost) < 0) { _heap[c] = _heap[p]; c = p; } else { break; } } _heap[c] = pair; } public (TCost cost, int to) Dequeue() { (TCost cost, int to) ret = _heap[0]; int n = Count - 1; var item = _heap[n]; int p = 0; int c = (p << 1) + 1; while (c < n) { if (c != n - 1 && Compare(_heap[c + 1].cost, _heap[c].cost) > 0) { ++c; } if (Compare(item.cost, _heap[c].cost) < 0) { _heap[p] = _heap[c]; p = c; c = (p << 1) + 1; } else { break; } } _heap[p] = item; Count--; return ret; } [MethodImpl(MethodImplOptions.AggressiveInlining)] private int Compare(TCost x, TCost y) => costOp.Compare(y, x); } } } "),
new AclFileInfo(@"Graph/DSU.cs", new string[] { @"AtCoder.DSU" }, new string[] { @"using System;", @"using System.Diagnostics;" }, new string[] {  }, @"namespace AtCoder { public class DSU { private int Count; private int[] ParentOrSize; public DSU(int n) { Count = n; ParentOrSize = new int[n]; for (int i = 0; i < ParentOrSize.Length; i++) ParentOrSize[i] = -1; } public int Merge(int a, int b) { Debug.Assert(0 <= a && a < Count); Debug.Assert(0 <= b && b < Count); int x = Leader(a), y = Leader(b); if (x == y) return x; if (-ParentOrSize[x] < -ParentOrSize[y]) (x, y) = (y, x); ParentOrSize[x] += ParentOrSize[y]; ParentOrSize[y] = x; return x; } public bool Same(int a, int b) { Debug.Assert(0 <= a && a < Count); Debug.Assert(0 <= b && b < Count); return Leader(a) == Leader(b); } public int Leader(int a) { if (ParentOrSize[a] < 0) return a; while (0 <= ParentOrSize[ParentOrSize[a]]) { (a, ParentOrSize[a]) = (ParentOrSize[a], ParentOrSize[ParentOrSize[a]]); } return ParentOrSize[a]; } public int Size(int a) { Debug.Assert(0 <= a && a < Count); return -ParentOrSize[Leader(a)]; } public Span<int[]> Groups() { int[] leaderBuf = new int[Count]; int[] id = new int[Count]; Span<int[]> result = new int[Count][]; int groupCount = 0; for (int i = 0; i < leaderBuf.Length; i++) { leaderBuf[i] = Leader(i); if (i == leaderBuf[i]) { id[i] = groupCount; result[id[i]] = new int[-ParentOrSize[i]]; groupCount++; } } int[] ind = new int[groupCount]; result = result.Slice(0, groupCount); for (int i = 0; i < leaderBuf.Length; i++) { var leaderID = id[leaderBuf[i]]; result[leaderID][ind[leaderID]] = i; ind[leaderID]++; } return result; } } } "),
new AclFileInfo(@"Graph/SCCGraph.cs", new string[] { @"AtCoder.SCCGraph" }, new string[] { @"using System.Collections.Generic;", @"using System.Diagnostics;" }, new string[] { @"Graph/Internal/InternalSCCGraph.cs" }, @"namespace AtCoder { [DebuggerDisplay(""Vertices = {_internal._n}, Edges = {_internal.edges.Count}"")] public class SCCGraph { Internal.SCCGraph _internal; public SCCGraph(int n) { Debug.Assert(unchecked((uint)n <= 100_000_000)); _internal = new Internal.SCCGraph(n); } public void AddEdge(int from, int to) { int n = _internal.VerticesNumbers; Debug.Assert(unchecked((uint)from < n)); Debug.Assert(unchecked((uint)to < n)); _internal.AddEdge(from, to); } public List<List<int>> SCC() => _internal.SCC(); } } "),
new AclFileInfo(@"DataStructure/String/ZAlgorithm.cs", new string[] { @"AtCoder.StringLib" }, new string[] { @"using System;", @"using System.Collections.Generic;" }, new string[] {  }, @"namespace AtCoder { public static partial class StringLib { public static int[] ZAlgorithm<T>(ReadOnlySpan<T> s) { int n = s.Length; if (n == 0) return new int[] { }; int[] z = new int[n]; z[0] = 0; for (int i = 1, j = 0; i < n; i++) { ref int k = ref z[i]; k = (j + z[j] <= i) ? 0 : Math.Min(j + z[j] - i, z[i - j]); while (i + k < n && EqualityComparer<T>.Default.Equals(s[k], s[i + k])) k++; if (j + z[j] < i + z[i]) j = i; } z[0] = n; return z; } public static int[] ZAlgorithm(string s) => ZAlgorithm(s.AsSpan()); public static int[] ZAlgorithm<T>(T[] s) => ZAlgorithm((ReadOnlySpan<T>)s); } } "),
new AclFileInfo(@"DataStructure/String/LCPArray.cs", new string[] { @"AtCoder.StringLib" }, new string[] { @"using System;", @"using System.Collections.Generic;", @"using System.Diagnostics;" }, new string[] {  }, @"namespace AtCoder { public static partial class StringLib { public static int[] LCPArray<T>(ReadOnlySpan<T> s, int[] sa) { Debug.Assert(1 <= s.Length); int[] rnk = new int[s.Length]; for (int i = 0; i < s.Length; i++) { rnk[sa[i]] = i; } int[] lcp = new int[s.Length - 1]; int h = 0; for (int i = 0; i < s.Length; i++) { if (h > 0) h--; if (rnk[i] == 0) continue; int j = sa[rnk[i] - 1]; for (; j + h < s.Length && i + h < s.Length; h++) { if (!EqualityComparer<T>.Default.Equals(s[j + h], s[i + h])) break; } lcp[rnk[i] - 1] = h; } return lcp; } public static int[] LCPArray(string s, int[] sa) => LCPArray(s.AsSpan(), sa); public static int[] LCPArray<T>(T[] s, int[] sa) => LCPArray((ReadOnlySpan<T>)s, sa); } } "),
new AclFileInfo(@"DataStructure/String/SuffixArray.cs", new string[] { @"AtCoder.StringLib" }, new string[] { @"using System;", @"using System.Collections.Generic;", @"using System.Diagnostics;", @"using System.Linq;" }, new string[] { @"DataStructure/String/Internal/InternalString.cs" }, @"namespace AtCoder { public static partial class StringLib { private static int[] SuffixArray<T>(ReadOnlyMemory<T> m) { var s = m.Span; var n = m.Length; var idx = Enumerable.Range(0, n).ToArray(); Array.Sort(idx, Compare); var s2 = new int[n]; var now = 0; for (int i = 0; i < idx.Length; i++) { if (i > 0 && !EqualityComparer<T>.Default.Equals(s[idx[i - 1]], s[idx[i]])) { now++; } s2[idx[i]] = now; } return Internal.String.SAIS(s2, now); int Compare(int l, int r) { var s = m.Span; return Comparer<T>.Default.Compare(s[l], s[r]); } } public static int[] SuffixArray(string s) { var n = s.Length; int[] s2 = s.Select(c => (int)c).ToArray(); return Internal.String.SAIS(s2, char.MaxValue); } public static int[] SuffixArray<T>(T[] s) => SuffixArray<T>(s.AsMemory()); public static int[] SuffixArray(int[] s, int upper) { Debug.Assert(0 <= upper); foreach (var si in s) { Debug.Assert(unchecked((uint)si) <= upper); } return Internal.String.SAIS(s, upper); } } } "),
new AclFileInfo(@"Math/Internal/InternalMath.cs", new string[] { @"AtCoder.Internal.InternalMath" }, new string[] { @"using System;", @"using System.Collections.Generic;", @"using System.Diagnostics;" }, new string[] { @"Math/MathLib.cs" }, @"namespace AtCoder.Internal { public static class InternalMath { public static long SafeMod(long x, long m) { x %= m; if (x < 0) x += m; return x; } public static (long, long) InvGCD(long a, long b) { a = SafeMod(a, b); if (a == 0) return (b, 0); long s = b, t = a; long m0 = 0, m1 = 1; long u; while (true) { if (t == 0) { if (m0 < 0) m0 += b / s; return (s, m0); } u = s / t; s -= t * u; m0 -= m1 * u; if (s == 0) { if (m1 < 0) m1 += b / t; return (t, m1); } u = t / s; t -= s * u; m1 -= m0 * u; } } private static readonly Dictionary<int, int> primitiveRootsCache = new Dictionary<int, int>() { { 2, 1 }, { 167772161, 3 }, { 469762049, 3 }, { 754974721, 11 }, { 998244353, 3 } }; public static int PrimitiveRoot(int m) { Debug.Assert(m >= 2); if (primitiveRootsCache.TryGetValue(m, out var p)) { return p; } return primitiveRootsCache[m] = Calculate(m); int Calculate(int m) { Span<int> divs = stackalloc int[20]; divs[0] = 2; int cnt = 1; int x = (m - 1) / 2; while (x % 2 == 0) { x >>= 1; } for (int i = 3; (long)i * i <= x; i += 2) { if (x % i == 0) { divs[cnt++] = i; while (x % i == 0) { x /= i; } } } if (x > 1) { divs[cnt++] = x; } for (int g = 2; ; g++) { bool ok = true; for (int i = 0; i < cnt; i++) { if (MathLib.PowMod(g, (m - 1) / divs[i], m) == 1) { ok = false; break; } } if (ok) { return g; } } } } } } "),
new AclFileInfo(@"Math/Internal/Butterfly.cs", new string[] { @"AtCoder.Internal.Butterfly<T>" }, new string[] { @"using System;" }, new string[] { @"Math/ModInt.cs", @"Bit/Internal/InternalBit.cs", @"Math/Internal/InternalMath.cs" }, @"namespace AtCoder.Internal { public static class Butterfly<T> where T : struct, IStaticMod { private static StaticModInt<T>[] sumE = CalcurateSumE(); private static StaticModInt<T>[] sumIE = CalcurateSumIE(); public static void Calculate(Span<StaticModInt<T>> a) { var n = a.Length; var h = InternalBit.CeilPow2(n); for (int ph = 1; ph <= h; ph++) { int w = 1 << (ph - 1); int p = 1 << (h - ph); var now = StaticModInt<T>.Raw(1); for (int s = 0; s < w; s++) { int offset = s << (h - ph + 1); for (int i = 0; i < p; i++) { var l = a[i + offset]; var r = a[i + offset + p] * now; a[i + offset] = l + r; a[i + offset + p] = l - r; } now *= sumE[InternalBit.BSF(~(uint)s)]; } } } public static void CalculateInv(Span<StaticModInt<T>> a) { var n = a.Length; var h = InternalBit.CeilPow2(n); for (int ph = h; ph >= 1; ph--) { int w = 1 << (ph - 1); int p = 1 << (h - ph); var iNow = StaticModInt<T>.Raw(1); for (int s = 0; s < w; s++) { int offset = s << (h - ph + 1); for (int i = 0; i < p; i++) { var l = a[i + offset]; var r = a[i + offset + p]; a[i + offset] = l + r; a[i + offset + p] = StaticModInt<T>.Raw( unchecked((int)((ulong)(default(T).Mod + l.Value - r.Value) * (ulong)iNow.Value % default(T).Mod))); } iNow *= sumIE[InternalBit.BSF(~(uint)s)]; } } } private static StaticModInt<T>[] CalcurateSumE() { int g = InternalMath.PrimitiveRoot((int)default(T).Mod); int cnt2 = InternalBit.BSF(default(T).Mod - 1); var e = new StaticModInt<T>(g).Pow((default(T).Mod - 1) >> cnt2); var ie = e.Inv(); var sumE = new StaticModInt<T>[cnt2 - 2]; Span<StaticModInt<T>> es = stackalloc StaticModInt<T>[cnt2 - 1]; Span<StaticModInt<T>> ies = stackalloc StaticModInt<T>[cnt2 - 1]; for (int i = es.Length - 1; i >= 0; i--) { es[i] = e; ies[i] = ie; e *= e; ie *= ie; } var now = StaticModInt<T>.Raw(1); for (int i = 0; i < sumE.Length; i++) { sumE[i] = es[i] * now; now *= ies[i]; } return sumE; } private static StaticModInt<T>[] CalcurateSumIE() { int g = InternalMath.PrimitiveRoot((int)default(T).Mod); int cnt2 = InternalBit.BSF(default(T).Mod - 1); var e = new StaticModInt<T>(g).Pow((default(T).Mod - 1) >> cnt2); var ie = e.Inv(); var sumIE = new StaticModInt<T>[cnt2 - 2]; Span<StaticModInt<T>> es = stackalloc StaticModInt<T>[cnt2 - 1]; Span<StaticModInt<T>> ies = stackalloc StaticModInt<T>[cnt2 - 1]; for (int i = es.Length - 1; i >= 0; i--) { es[i] = e; ies[i] = ie; e *= e; ie *= ie; } var now = StaticModInt<T>.Raw(1); for (int i = 0; i < sumIE.Length; i++) { sumIE[i] = ies[i] * now; now *= es[i]; } return sumIE; } } } "),
new AclFileInfo(@"Math/Internal/Barrett.cs", new string[] { @"AtCoder.Internal.Barrett" }, new string[] { @"using System;", @"using System.Collections.Generic;", @"using System.Numerics;", @"using System.Runtime.Intrinsics;", @"using System.Runtime.Intrinsics.X86;", @"using System.Text;" }, new string[] {  }, @"namespace AtCoder.Internal { public class Barrett { public uint Mod { get; private set; } private ulong IM; public Barrett(uint m) { Mod = m; IM = unchecked((ulong)-1) / m + 1; } public uint Mul(uint a, uint b) { ulong z = a; z *= b; if (!Bmi2.X64.IsSupported) return (uint)(z % Mod); var x = Bmi2.X64.MultiplyNoFlags(z, IM); var v = unchecked((uint)(z - x * Mod)); if (Mod <= v) v += Mod; return v; } } } "),
new AclFileInfo(@"Util/Internal/CollectionDebugView.cs", new string[] { @"AtCoder.Util.Internal.CollectionDebugView<T>" }, new string[] { @"using System;", @"using System.Collections.Generic;", @"using System.Diagnostics;", @"using System.Linq;" }, new string[] {  }, @"namespace AtCoder.Util.Internal { internal class CollectionDebugView<T> { private IEnumerable<T> collection; public CollectionDebugView(IEnumerable<T> collection) { this.collection = collection ?? throw new ArgumentNullException(nameof(collection)); } [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)] public T[] Items => collection.ToArray(); } } "),
new AclFileInfo(@"Bit/Internal/InternalBit.cs", new string[] { @"AtCoder.Internal.InternalBit" }, new string[] { @"using System.Diagnostics;", @"using System.Numerics;", @"using System.Runtime.CompilerServices;", @"using System.Runtime.Intrinsics.X86;" }, new string[] {  }, @"namespace AtCoder.Internal { public static class InternalBit { public static int CeilPow2(int n) { var un = (uint)n; if (un <= 1) return 0; return BitOperations.Log2(un - 1) + 1; } [MethodImpl(MethodImplOptions.AggressiveInlining)] public static int ExtractLowestSetBit(int n) { if (Bmi1.IsSupported) { return (int)Bmi1.ExtractLowestSetBit((uint)n); } return n & -n; } [MethodImpl(MethodImplOptions.AggressiveInlining)] public static int BSF(uint n) { Debug.Assert(n >= 1); return BitOperations.TrailingZeroCount(n); } } } "),
new AclFileInfo(@"Graph/Internal/InternalSCCGraph.cs", new string[] { @"AtCoder.Internal.SCCGraph", @"AtCoder.Internal.SCCGraph.CSR", @"AtCoder.Internal.SCCGraph.Edge" }, new string[] { @"using System;", @"using System.Collections.Generic;", @"using System.Diagnostics;", @"using System.Linq;" }, new string[] {  }, @"namespace AtCoder.Internal { [DebuggerDisplay(""Vertices = {_n}, Edges = {edges.Count}"")] public class SCCGraph { private readonly int _n; private readonly List<Edge> edges; public int VerticesNumbers => _n; public SCCGraph(int n) { _n = n; edges = new List<Edge>(); } public void AddEdge(int from, int to) => edges.Add(new Edge(from, to)); public (int groupNum, int[] ids) SCCIDs() { var g = new CSR(_n, edges); int nowOrd = 0; int groupNum = 0; var visited = new Stack<int>(_n); var low = new int[_n]; var ord = Enumerable.Repeat(-1, _n).ToArray(); var ids = new int[_n]; for (int i = 0; i < ord.Length; i++) { if (ord[i] == -1) { DFS(i); } } foreach (ref var x in ids.AsSpan()) { x = groupNum - 1 - x; } return (groupNum, ids); void DFS(int v) { low[v] = nowOrd; ord[v] = nowOrd++; visited.Push(v); for (int i = g.Start[v]; i < g.Start[v + 1]; i++) { int to = g.EList[i]; if (ord[to] == -1) { DFS(to); low[v] = Math.Min(low[v], low[to]); } else { low[v] = Math.Min(low[v], ord[to]); } } if (low[v] == ord[v]) { while (true) { int u = visited.Pop(); ord[u] = _n; ids[u] = groupNum; if (u == v) { break; } } groupNum++; } } } public List<List<int>> SCC() { var (groupNum, ids) = SCCIDs(); var counts = new int[groupNum]; foreach (var x in ids) { counts[x]++; } var groups = new List<List<int>>(groupNum); for (int i = 0; i < groupNum; i++) { groups.Add(new List<int>(counts[i])); } for (int i = 0; i < ids.Length; i++) { groups[ids[i]].Add(i); } return groups; } private class CSR { public int[] Start { get; } public int[] EList { get; } public CSR(int n, List<Edge> edges) { Start = new int[n + 1]; EList = new int[edges.Count]; foreach (var e in edges) { Start[e.From + 1]++; } for (int i = 1; i <= n; i++) { Start[i] += Start[i - 1]; } var counter = new int[Start.Length]; Start.CopyTo(counter, 0); foreach (var e in edges) { EList[counter[e.From]++] = e.To; } } } [DebuggerDisplay(""From = {From}, To = {To}"")] private readonly struct Edge { public int From { get; } public int To { get; } public Edge(int from, int to) { From = from; To = to; } } } } "),
new AclFileInfo(@"DataStructure/String/Internal/InternalString.cs", new string[] { @"AtCoder.Internal.String" }, new string[] { @"using System;", @"using System.Collections.Generic;", @"using System.Linq;" }, new string[] {  }, @"namespace AtCoder.Internal { public static class String { private static int[] SANaive(ReadOnlyMemory<int> sm) { var n = sm.Length; var sa = Enumerable.Range(0, n).ToArray(); Array.Sort(sa, Compare); return sa; int Compare(int l, int r) { var s = sm.Span; while (l < s.Length && r < s.Length) { if (s[l] != s[r]) { return s[l] - s[r]; } l++; r++; } return r - l; } } private static int[] SADoubling(ReadOnlyMemory<int> sm) { var s = sm.Span; var n = s.Length; var sa = Enumerable.Range(0, n).ToArray(); var rnk = new int[n]; var tmp = new int[n]; s.CopyTo(rnk); for (int k = 1; k < n; k <<= 1) { Array.Sort(sa, Compare); tmp[sa[0]] = 0; for (int i = 1; i < sa.Length; i++) { tmp[sa[i]] = tmp[sa[i - 1]] + (Compare(sa[i - 1], sa[i]) < 0 ? 1 : 0); } (tmp, rnk) = (rnk, tmp); int Compare(int x, int y) { if (rnk[x] != rnk[y]) { return rnk[x] - rnk[y]; } int rx = x + k < n ? rnk[x + k] : -1; int ry = y + k < n ? rnk[y + k] : -1; return rx - ry; } } return sa; } public static int[] SAIS(ReadOnlyMemory<int> sm, int upper) => SAIS(sm, upper, 10, 40); public static int[] SAIS(ReadOnlyMemory<int> sm, int upper, int thresholdNaive, int thresholdDouling) { var s = sm.Span; var n = s.Length; if (n == 0) { return Array.Empty<int>(); } else if (n == 1) { return new int[] { 0 }; } else if (n == 2) { if (s[0] < s[1]) { return new int[] { 0, 1 }; } else { return new int[] { 1, 0 }; } } else if (n < thresholdNaive) { return SANaive(sm); } else if (n < thresholdDouling) { return SADoubling(sm); } var sa = new int[n]; var ls = new bool[n]; for (int i = sa.Length - 2; i >= 0; i--) { ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]); } var sumL = new int[upper + 1]; var sumS = new int[upper + 1]; for (int i = 0; i < s.Length; i++) { if (!ls[i]) { sumS[s[i]]++; } else { sumL[s[i] + 1]++; } } for (int i = 0; i < sumL.Length; i++) { sumS[i] += sumL[i]; if (i < upper) { sumL[i + 1] += sumS[i]; } } var lmsMap = GetFilledArray(-1, n + 1); int m = 0; for (int i = 1; i < ls.Length; i++) { if (!ls[i - 1] && ls[i]) { lmsMap[i] = m++; } } var lms = new List<int>(m); for (int i = 1; i < ls.Length; i++) { if (!ls[i - 1] && ls[i]) { lms.Add(i); } } Induce(lms); if (m > 0) { var sortedLms = new List<int>(m); foreach (var v in sa) { if (lmsMap[v] != -1) { sortedLms.Add(v); } } var recS = new int[m]; var recUpper = 0; recS[lmsMap[sortedLms[0]]] = 0; for (int i = 1; i < sortedLms.Count; i++) { var l = sortedLms[i - 1]; var r = sortedLms[i]; var endL = (lmsMap[l] + 1 < m) ? lms[lmsMap[l] + 1] : n; var endR = (lmsMap[r] + 1 < m) ? lms[lmsMap[r] + 1] : n; var same = true; if (endL - l != endR - r) { same = false; } else { while (l < endL) { if (s[l] != s[r]) { break; } l++; r++; } if (l == n || s[l] != s[r]) { same = false; } } if (!same) { recUpper++; } recS[lmsMap[sortedLms[i]]] = recUpper; } var recSA = SAIS(recS, recUpper, thresholdNaive, thresholdDouling); for (int i = 0; i < sortedLms.Count; i++) { sortedLms[i] = lms[recSA[i]]; } Induce(sortedLms); } return sa; void Induce(List<int> lms) { var s = sm.Span; sa.AsSpan().Fill(-1); var buf = new int[sumS.Length]; sumS.AsSpan().CopyTo(buf); foreach (var d in lms) { if (d == n) { continue; } sa[buf[s[d]]++] = d; } sumL.AsSpan().CopyTo(buf); sa[buf[s[n - 1]]++] = n - 1; for (int i = 0; i < sa.Length; i++) { int v = sa[i]; if (v >= 1 && !ls[v - 1]) { sa[buf[s[v - 1]]++] = v - 1; } } sumL.AsSpan().CopyTo(buf); for (int i = sa.Length - 1; i >= 0; i--) { int v = sa[i]; if (v >= 1 && ls[v - 1]) { sa[--buf[s[v - 1] + 1]] = v - 1; } } } } private static T[] GetFilledArray<T>(T value, int length) { var result = new T[length]; result.AsSpan().Fill(value); return result; } } } "),
            });
    }
}
